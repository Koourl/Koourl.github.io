<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KoourlのBLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-15T08:59:41.713Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Koourl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2-勾股数组与单位圆</title>
    <link href="http://yoursite.com/2020/08/15/2-%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%8E%E5%8D%95%E4%BD%8D%E5%9C%86/"/>
    <id>http://yoursite.com/2020/08/15/2-%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%8E%E5%8D%95%E4%BD%8D%E5%9C%86/</id>
    <published>2020-08-15T08:57:43.000Z</published>
    <updated>2020-08-15T08:59:41.713Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二：勾股数组与单位圆</span><br></pre></td></tr></table></figure><p>在前一章中我们描述了</p><script type="math/tex; mode=display">a^2+b^2=c^2</script><p>的所有整数解a,b,c.如果使用了c^2除这个方程则得</p><script type="math/tex; mode=display">(\frac{a}{c})^2+(\frac{b}{c})^2=1.</script><p>所以，有理数对（a/c，b/c）是方程x^2+y^2=1的解</p><p>大家知道方程x^2+y^2=1代表中心在（0，0）半径为1的圆C，那么我们怎么求的新的点呢？</p><p>我们打算从几何角度求圆C上无坐标与y坐标都是有理数的点.注意圆上 有4个明显的具有有理数坐标的点：      （±1, 0） 与（0, ±1）.假设我们取任意（有理）数观 察过点（-1, 0）斜率为m的直线丄（见图）. 直线L由方程</p><p><img src="https://pic.downk.cc/item/5f3518ac14195aa5945243d9.jpg" style="zoom: 50%;" /></p><script type="math/tex; mode=display">L:y=m(x+1)    (点斜式)</script><p>给出.从图形上看交集C∩L恰好由两个点组成，其中一个是（-1, 0）,我们来求另 一个.</p><p>为求C与L的交集，需要解关于X与y的方程组：</p><script type="math/tex; mode=display">x^2+y^2=1，y=m(x+1)</script><p>将第二个方程代入第一个方程并化简得到</p><script type="math/tex; mode=display">x^2+(m(x+1))^2=1 \\x^2+m^2(x^2+2x+1)=1\\(m^2+1)x^2+2m^2x+(m^2-1)=0</script><p>这正好是个二次方程，所以可用二次方程求根公式来解出</p><p>但是，有一种更容易的解 方程的方法.由于点（-1,0）在C与&amp;上，我们知道x= -1必是一个解.因此可用x+1去除二次多项式来求另一个根：</p><script type="math/tex; mode=display">x+1 )\frac{(m^2+1)x^2+(m^2-1)}{(m^2+1)x^2+2m^2x+(m^2-1)}</script><p>所以，另一个根是方程 (m^2+1)x^2+(m^2-1)=0的解，这意味着:</p><script type="math/tex; mode=display">x=\frac{1-m^2}{1+m^2}</script><p>将x的值代入直线L的方程y = m(x + l)来求y坐标：</p><script type="math/tex; mode=display">y=m(x+1)=m(\frac{1-m^2}{1+m^2}+1)=\frac{2m}{1+m^2}</script><p>这样，对每个有理数m得到方程x^2+y^2=1的一个有理数解</p><script type="math/tex; mode=display">(\frac{1-m^2}{1+m^2},\frac{2m}{1+m^2})</script><p>另一方面，如果得到一个有理数解（x1，y1），则过点（x1，y1）与（-1, 0）的直线斜 率是有理数.所以，通过取m的所有可能值，上述过程就生成方程x2 +/ =1的所有有 理数解.（点（-1,0）例外，它对应着斜率m = 8的铅直线.）我们将结果概括成下述 定理.</p><p><strong>定理3.1</strong>圆x^2+y^2=1上的坐标是有理数的点都可由公式:</p><script type="math/tex; mode=display">(x,y)=(\frac{1-m^2}{1+m^2},\frac{2m}{1+m^2})</script><p>得到，其中m取有理数值.（点（-1, 0）例外，这是当m➡+∞时的极限值.）</p><p>那么，圆上的有理点公式如何与勾股数组公式联系在一起呢？如果将有理数m写成分数v/u,则公式变成:</p><script type="math/tex; mode=display">(x,y)=(\frac{u^2-v^2}{u^2+v^2},\frac{2uv}{u^2+v^2})</script><p>消去分母就给出勾股数组:</p><script type="math/tex; mode=display">(a,b,c)=(u^2-v^2,2uv,u^2+v^2)</script><p>虽然描述本原勾股数组需要对u与v作一些限制，但这是描述所有勾股数组的另一种方法.通过令</p><script type="math/tex; mode=display">u=\frac{s+t}{2}与v=\frac{s-t}{2}</script><p>可将这里的描述与第2章的公式相联系。</p>]]></content>
    
    <summary type="html">
    
      2-勾股数组与单位圆
    
    </summary>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/categories/NUM-THEORY/"/>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/tags/NUM-THEORY/"/>
    
      <category term="2-勾股数组与单位圆" scheme="http://yoursite.com/tags/2-%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E4%B8%8E%E5%8D%95%E4%BD%8D%E5%9C%86/"/>
    
  </entry>
  
  <entry>
    <title>3-高次幂之和与费马大定理</title>
    <link href="http://yoursite.com/2020/08/15/3-%E9%AB%98%E6%AC%A1%E5%B9%82%E4%B9%8B%E5%92%8C%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/15/3-%E9%AB%98%E6%AC%A1%E5%B9%82%E4%B9%8B%E5%92%8C%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86/</id>
    <published>2020-08-15T08:57:43.000Z</published>
    <updated>2020-08-15T09:01:00.317Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三：高次幂之和与费马大定理</span><br></pre></td></tr></table></figure><p>在前两章我们发现方程</p><script type="math/tex; mode=display">a^2+b^2=c^2</script><p>有许多整数解a,b,c.自然人们要问当指数2换成更大的整数时相应的方程是否有解. </p><p>例如，方程</p><script type="math/tex; mode=display">a^3+b^3=c^3,a^4+b^4=c^4与a^5+b^5=c^5</script><p>有非零整数解a,b,c吗？答案是否定的.在1637年前后，费马证明上述指数为4的方 程没有解.在18和19世纪高斯与欧拉(Leonhard Euler)证明指数为3的方程没有解，狄 利克雷与勒让德(Adrien Legendre)证明了 5次方程没有解.n≥3时方程</p><script type="math/tex; mode=display">a^n+b^n=c^n</script><p>没有正整数解的这个一般性结论被称为“费马大定理”.自费马在书的边沿写出如下断言以来的350多年里，人们对它痴迷到近乎疯狂的地步：</p><p>不可能将一个3次方分成两个3次方之和；一个4次方不可能写成两个4次方之和；一般地，任何高于2次的幂不可能写成两个同次幂之和.我已发现一个美妙的证明，这里空白太小写不下.</p><p>今天，几乎没有数学家相信费马给出过他的这个“定理”的有效证明，这个“定理”之 所以被称为他的最后定理，是因为这是他最后一个未被证明的断言.费马大定理的历史 令人着迷，许许多多的数学家为它做出了重要贡献.这方面一个简要的综述也够编本书 了，但这不是本书的目标，所以我们只作一些简要的注记.</p><p>与对特定指数n的证明相对照，关于费马大定理最初的一般结果之一由热尔曼于 1823年给出.她证明</p><p>p与2p+1都是素数时方程a^p+b^p=c^p,没有p不整除积abc的整数解a, b, c.</p><p>接着，A. Wieferich于1909年得到一个相似结果：</p><p>如果2^v-2不被p^2整除， 则相同结论成立.</p><p> 19世纪后半叶一批数学家(尤其是3位大佬) 开创了被称为代数数论的数学新领 域，并应用他们的理论证明了费马大定理对许多指数成立，虽然仅限于有限数目的指 数.1985年，L.M.Adleman、D. R. Heath-Brown与E. Fouvry使用改进的热尔曼判别法和艰深的解析估计证明了</p><p>存在无穷多个素数P使得</p><script type="math/tex; mode=display">a^p+b^p=c^p</script><p>没有解 且p不整除abc.</p><p>剩下的就都是大佬的研究介绍了，不多赘述。</p>]]></content>
    
    <summary type="html">
    
      3-高次幂之和与费马大定理
    
    </summary>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/categories/NUM-THEORY/"/>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/tags/NUM-THEORY/"/>
    
      <category term="3-高次幂之和与费马大定理" scheme="http://yoursite.com/tags/3-%E9%AB%98%E6%AC%A1%E5%B9%82%E4%B9%8B%E5%92%8C%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>4-整除性与最大公因数（GCD）</title>
    <link href="http://yoursite.com/2020/08/15/4-%E6%95%B4%E9%99%A4%E6%80%A7%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%EF%BC%88GCD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/08/15/4-%E6%95%B4%E9%99%A4%E6%80%A7%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%EF%BC%88GCD%EF%BC%89/</id>
    <published>2020-08-15T08:57:43.000Z</published>
    <updated>2020-08-15T09:09:40.926Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">四：整除性与最大公因数（GCD）</span><br></pre></td></tr></table></figure><p>​                设m与n为整数，如果存在整数k使得n=mk，则m整除n，记作m|n</p><p>​                GCD的计算方法：欧几里得算法：</p><script type="math/tex; mode=display">A=Q*B+R</script><p>​                不断的用B替换A，用R替换B，直到R=0时结束</p><p>​                分析：</p><script type="math/tex; mode=display">A=Q1*B+R1\\B=Q2*R1+R2\\R1=Q3*R2+R3\\……\\R(n-2)=Qn*R(n-1)+Rn\\R(n-1)=Q(n+1)*Rn+0\\</script><p>​                令R0=B，R-1=A，那么通式为：</p><script type="math/tex; mode=display">R（i-1）=Q（i+1）*Ri+R（i+1）</script><p>​                为什么Rn为公因数呢？</p><p>​                由上述公式从下往上可得：</p><script type="math/tex; mode=display">Rn|R(n-1)\\Rn|R(n-2)\\……\\Rn|a\\Rn|b</script><p>​                由上得，这样一定可以得到a与b的公因数</p><p>​                这样产生的一定最大吗？</p><p>​                设D为A和B的任意公因数，那么由上述公式可得：</p><script type="math/tex; mode=display">D|A,B,R1\\D|R2\\D|R3\\……\\D|Rn</script><p>​                因为D为A和B的任意公因数，则Rn必为最大公因数</p><p>​                综上所述：</p><p>​                                定理：欧几里得算法</p><p>​                                            令R（-1）=A，R0=B，使得：</p><script type="math/tex; mode=display">R（i-1）=Q（i+1）*Ri+R（i+1）</script><p>​                                            直到某余数R（n+1）为0，最后非零的Rn就为最大公因数</p><p>​                为什么总有Rn会等于0呢？</p><p>​                显然余数R在0与B-1之间，所以，计算中余数在不断减小即B&gt;R0&gt;R1&gt;R2&gt;R3……</p><p>​                所以得到非负整数的严格递减序列，所以最后必然达到0</p><p>​                显然，经过B步就可以得到余数0，但是不仅如此</p><p>​                步数最多为B的位数的7倍，所以即使数据成百上千位，也很容易计算</p>]]></content>
    
    <summary type="html">
    
      4-整除性与最大公因数（GCD）
    
    </summary>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/categories/NUM-THEORY/"/>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/tags/NUM-THEORY/"/>
    
      <category term="4-整除性与最大公因数（GCD）" scheme="http://yoursite.com/tags/4-%E6%95%B4%E9%99%A4%E6%80%A7%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%EF%BC%88GCD%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>周讲-1</title>
    <link href="http://yoursite.com/2020/08/08/%E5%91%A8%E8%AE%B2-1/"/>
    <id>http://yoursite.com/2020/08/08/%E5%91%A8%E8%AE%B2-1/</id>
    <published>2020-08-08T10:35:36.000Z</published>
    <updated>2020-08-08T10:38:46.966Z</updated>
    
    <content type="html"><![CDATA[<p>二分图：可以将顶点看为两个集合，集合内部无联系，只在两个集合间有联系，                                                                            存在以上划分方法的图称为二分图</p><p>​    性质：二分图内每个环的边数都为偶数</p><p>​    问题种类：</p><p>​        匹配问题：设G=<V , E>是二分图，且E是V1和V2的笛卡尔积的集合</p><p>​            （第一个为V1的顶点，第二个为V2的顶点，构成的边集，又因为二分图的定义，所以就是全部边的集合）</p><p>​                            在E中有子集M，M内的边没有相邻的边称为M为G的一个匹配，所以具有最大匹配的问题</p><p>​                            当V1=V2=M时，则成M为完美匹配（M中的边称为杆）</p><p>​                            显然，完美匹配定为最大匹配，但反之则不对</p><p>​                            四个定义：当有杆（u，v）属于M，且u为V1中的节点，v为V2中的节点，则称两个节点被M匹配</p><p>​                                                当有一个杆可以匹配节点u时，u称为M的饱和点，否则为不饱和点</p><p>​                                                当一条交替属于M和E\M的边构成的初级路为交错路</p><p>​                                                当一条已u为起点，v为终点，且u和v都是不饱和点的交错路为增广路</p><p>​    算法：匈牙利算法（找到最大匹配）</p><p>​                思想：不停的寻找增广路来增加匹配中的匹配边和匹配点，来找到最大匹配</p><p>​                步骤：首先取任意匹配M（可为空或者只有一条边）</p><p>​                            然后找到V1中为M的不饱和点的u，如果S寻找完毕后为空集，则称M已经为最大匹配</p><p>​                            如果S不为空，取任意饱和点u0做为起点，从此起点走出几条交错路Pi</p><p>​                            如果其中的Pi有增广路，则令M为(M\P)U(P\M)，且新的M的大小为旧的M的大小+1，回到第三步</p><p>​                            如果没有一条路为增广路，则令u0弹出S，弹出后如果S不为空则返回第三步</p><p>​                            如果为空则M为最大匹配</p><p>​    </p><p>​    单源最短路：</p><p>​                算法：SPFA</p><p>​                        思想：用数组记录每个节点的最短路径估计值，用邻接矩阵储存图G</p><p>​                                    采用动态逼近方法：用一个先进先出的队列来保存待优化的节点</p><p>​                                                                        优化时：每次去除队首的节点设为u，并且用u点当前的最短路径估计值</p><p>​                                                                                        对离开u点指向v点进行松弛操作，如果对v点的最短路有调整</p><p>​                                                                                        并且v不在当前的队列中时，将v点加入队尾</p><p>​                                                                        重复上述操作直至队列为空</p><p>​                        实现方法：存入图</p><p>​                                            开一个队列，先将开始时的节点放入</p><p>​                                            每次取出一个节点，设为X，，遍历与X相通的节点Y</p><p>​                                                对比Y的长度和X的长度+X到Y的长度，如果X的长度+X到Y的长度&lt;Y的长度，则需更新</p><p>​                                                更新：存入最短路</p><p>​                                                            由于改变了原有的长度，则往后更新与这个节点相连的最短路</p><p>​                                                            期间记录这个节点的进队次数，判断是否存在负环</p><p>​                                                                                （如果一个节点进入超过N次则有负环）</p><p>​                                            直到队列为空</p>]]></content>
    
    <summary type="html">
    
      周讲-1
    
    </summary>
    
    
      <category term="WEAKLY S" scheme="http://yoursite.com/categories/WEAKLY-S/"/>
    
    
      <category term="WEAKLY S" scheme="http://yoursite.com/tags/WEAKLY-S/"/>
    
      <category term="周讲-1" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B2-1/"/>
    
  </entry>
  
  <entry>
    <title>1-勾股数组</title>
    <link href="http://yoursite.com/2020/08/08/1-%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/08/08/1-%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84/</id>
    <published>2020-08-08T03:16:40.000Z</published>
    <updated>2020-08-09T07:25:00.045Z</updated>
    
    <content type="html"><![CDATA[<pre><code>一：勾股数组</code></pre><p>​                勾股数组（a , b , c），如果其中 a , b , c 无公因数，且满足</p><script type="math/tex; mode=display">a^2+b^2=c^2</script><p>​                则称其为本源勾股数组（PPT）</p><p>​                    首先：积累数据，带入计算机让其产生本源勾股数组</p><p>​                            （3 , 4 , 5）（5 , 12 , 13）（8 , 15 , 17）（7 , 24 , 25）（20 , 21 , 29）（9 , 40 , 41 ）</p><p>​                            （12 , 35 , 37）（11 , 60 , 61）（28 , 45 , 53）（33 , 56 , 65）（16 , 63 , 65）</p><p>​                                观察：a与b奇偶性不同，且c为奇数</p><p>​                                        证（1）当a与b都为偶数是，c必然也为偶数，那么他们有公约数2，不本源</p><p>​                                            （2）设：整数x，y，z</p><p>​                                                            令a=2x+1，b=2y+1，c=2z</p><script type="math/tex; mode=display">（2x+1）^2+（2y+1）^2=（2z）^2</script><script type="math/tex; mode=display"> 4x^2+4x+4y^2+4y+2=4z^2</script><script type="math/tex; mode=display">2x^2+2x+2y^2+2y+1=2z^2</script><p>​                                                            左侧为奇数，右侧为偶数，左不等于右，</p><p>​                                                            所以假设a与b都为奇数不成立</p><p>​                                                所以，a与b的奇偶性不同，c为奇数</p><p>​                        如何进行求解呢？</p><p>​                                    首先将其因式分解得</p><script type="math/tex; mode=display">a^2=c^2-b^2=(c-b)(c+b)</script><p>​                                    取一些值可得</p><script type="math/tex; mode=display">3^2=5^2-4^2=(5-4)(5+4)=1*9</script><script type="math/tex; mode=display">15^2=17^2-8^2=(17-8)(17+8)=9*25</script><script type="math/tex; mode=display">35^2=37^2-12^2=(37-12)(37+12)=25*49</script><script type="math/tex; mode=display">33^2=65^2-56^2=(65-56)(65+56)=9*121</script><script type="math/tex; mode=display">21^2=29^2-20^2=(29-20)(29+20)=9*49</script><script type="math/tex; mode=display">63^2=65^2-16^2=(65-16)(65+16)=49*81</script><p>​                                    观察到（c - b）与（c+b）总是为平方数，且（c-b）与（c+b）没有公因数</p><p>​                                            证：设d为（c-b）和（c+b）的公因数，那么d可以整除</p><script type="math/tex; mode=display">（c+b）+（c-b）=2c</script><script type="math/tex; mode=display">（c+b）-（c-b）=2b</script><script type="math/tex; mode=display">（c-b）*（c+b）=a^2</script><p>​                                                    因为b与c无公因数，所以d=1或2，因为a为奇数，所以d=1</p><p>​                                                    所以（c-b）和（c+b）无公因数，因为</p><script type="math/tex; mode=display">（c-b）*（c+b）=a^2</script><p>​                                                    所以（c-b）和（c+b）都只能以平方数出现</p><p>​                勾股数组定理：每个本源勾股数组（a，b，c），都可以从</p><script type="math/tex; mode=display">a=st,b=((s^2-t^2)/2),c=((s^2+t^2)/2),s>t>=1</script><p>​                                            s，t为无公因数的奇数给出                                                    </p><p>​                                            勾股数组定理的证明还差一步，如果已证明（a , b , c）为本源勾股数组</p><p>​                                            a为奇数，要证明这些公式给出的一定为PPT，通过代数运算</p><script type="math/tex; mode=display">（s*t）^2+((s^2-t^2)/2)^2=s^2t^2+(s^4-2s^2t^2+t^4)/4=(s^4+2s^2t^2+t^4)/4=((s^2+t^2)/2)^2</script><p>​                                            得到其给出的一定为勾股数组，但还需证</p><script type="math/tex; mode=display">s*t,((s^2-t^2)/2),((s^2+t^2)/2)</script><p>​                                            没有公因数，用素数的性质很容易证明（推迟到第六章）</p>]]></content>
    
    <summary type="html">
    
      1-勾股数组
    
    </summary>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/categories/NUM-THEORY/"/>
    
    
      <category term="NUM THEORY" scheme="http://yoursite.com/tags/NUM-THEORY/"/>
    
      <category term="1-勾股数组" scheme="http://yoursite.com/tags/1-%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>10-插头</title>
    <link href="http://yoursite.com/2020/08/03/10-%E6%8F%92%E5%A4%B4/"/>
    <id>http://yoursite.com/2020/08/03/10-%E6%8F%92%E5%A4%B4/</id>
    <published>2020-08-03T03:35:14.000Z</published>
    <updated>2020-08-08T10:34:26.664Z</updated>
    
    <content type="html"><![CDATA[<pre><code>URAL 1519</code></pre><h1 id="Formula"><a href="#Formula" class="headerlink" title="Formula"></a>Formula</h1><p>Time limit    1000 ms    Memory limit    65536 kB</p><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Regardless of the fact, that Vologda could not get rights to hold the Winter Olympic games of 20**, it is well-known, that the city will conduct one of the Formula 1 events. Surely, for such an important thing a new race circuit should be built as well as hotels, restaurants, international airport - everything for Formula 1 fans, who will flood the city soon. But when all the hotels and a half of the restaurants were built, it appeared, that at the site for the future circuit a lot of gophers lived in their holes. Since we like animals very much, ecologists will never allow to build the race circuit over the holes. So now the mayor is sitting sadly in his office and looking at the map of the circuit with all the holes plotted on it.</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Who will be smart enough to draw a plan of the circuit and keep the city from inevitable disgrace? Of course, only true professionals - battle-hardened programmers from the first team of local technical university!.. But our heroes were not looking for easy life and set much more difficult problem: “Certainly, our mayor will be glad, if we find how many ways of building the circuit are there!” - they said.</p><p>It should be said, that the circuit in Vologda is going to be rather simple. It will be a rectangle <strong>N*</strong> <strong>M</strong> cells in size with a single circuit segment built through each cell. Each segment should be parallel to one of rectangle’s sides, so only right-angled bends may be on the circuit. At the picture below two samples are given for <strong>N</strong> = <strong>M</strong> = 4 (gray squares mean gopher holes, and the bold black line means the race circuit). There are no other ways to build the circuit here.</p><p><img src="https://vj.z180.cn/7def85661c8a17e1dea6c2071a7a5aa4?v=1590505376" alt="Problem illustration"></p><p>Input</p><p>The first line contains the integer numbers <strong>N</strong> and <strong>M</strong> (2 ≤ <strong>N</strong>, <strong>M</strong> ≤ 12). Each of the next <strong>N</strong> lines contains <strong>M</strong> characters, which are the corresponding cells of the rectangle. Character “.” (full stop) means a cell, where a segment of the race circuit should be built, and character “*” (asterisk) - a cell, where a gopher hole is located. There are at least 4 cells without gopher holes.</p><p>Output</p><p>You should output the desired number of ways. It is guaranteed, that it does not exceed 2 63-1.</p><p>题意：给一个有障碍的网格，求其哈密尔顿回路的总数</p><p>分析：所谓哈密尔顿回路即：一条路径通过所有方格，且所有方格只有一次</p><p>​            看到这N和M2到12的超小数据范围，如果直接DFS头铁暴力直接爆炸</p><p>​            那么肯定要用到状压DP，可是，之前的状压DP都是很简单的状态，也没有这样的一个图的类型</p><p>​            那么要怎么办呢？</p><p>​            有请小学二年级学过的插头DP！</p><p>​            首先介绍一下用到的名词：</p><p>​                插头：将一个格子与一个格子看成一块一块的拼图，两个拼图中间</p><p>​                    会有凹进去的部分也会有凸出来的部分，将凸出来与凹进去的部分，我们叫做插头</p><p>​                    可以理解为能把两个方格连在一起的东西</p><p>​                轮廓线：就是已经进行过转移和没进行过转移的格子之间的分界线</p><p>​            在插头DP中需要压缩的部分就是轮廓线上的插头状态</p><p>​            插头的状态有两种，如上所说，一种凸，一种凹，我们将凸叫做出插头，状态定义为1</p><p>​                                                                                                    将凹叫做入插头，状态定义为2</p><p>​            这样我们就得到了一个三进制的状态，可三进制的状态需要我们重载全部的操作符（好麻烦啊）</p><p>​            所以我们使用四进制来保存这个状态，四进制就是两位2进制，所以直接用2进制的运算即可</p><p>​            一下用4*4的格子举例说明（为了方便，统一，如果无特殊要求则左边的插头为1，右边的为2）</p><p><img src="https://pic.downk.cc/item/5ed23434c2a9a83be5875c74.png" alt=""></p><p>​            如图示，现在要进行的是图中橙色的格子，轮廓线为绿色，插头状态为红色</p><p>​                                                        <img src="https://pic.downk.cc/item/5ed23477c2a9a83be587af93.png" alt=""></p><p>​            如上图，转移橙色的格子时，需要将绿色的轮廓线转移为蓝色的轮廓线</p><p>​            为了方便表示，我们将橙色的格子叫做关键方格，关键方格左边和上边的轮廓线</p><p>​            叫做关键轮廓线分别为B1，B2</p><p>​            那么接下来讨论转移时会发生的所有状态可能</p><p>​                    1：B1，B2都为0</p><p>​                        他们这两个边上的插头都为0，那么就说明只能添加一个下插头，一个右插头来形成一个路径</p><p><img src="https://pic.downk.cc/item/5ed2348ac2a9a83be587cb53.png" alt=""></p><p>​                    2：B1不为0，B2为0，或者B2不为0，B1为0</p><p>​                        那么就相当于只有一个插头存在，如果那么都有直接可以走过去，不添加减少插头</p><p>​                        或者要将这个插头变为另一种插头</p><p><img src="https://pic.downk.cc/item/5ed234a6c2a9a83be587f5d0.png" alt=""></p><p><img src="https://pic.downk.cc/item/5ed234bec2a9a83be588115e.png" alt=""></p><p>​                        （从上往下的插头也是如此）</p><p>​                    3：都为1或者都为2</p><p>​                        那么就需要向前找到或者向后找到对应的2或者1，因为需要让他们的状态改变</p><p>​                        如果B1，B2都为1，那么需要减去这两个1（把他俩连起来），后面的2有一个要变为1</p><p>​                        因为不能2连2</p><p><img src="https://pic.downk.cc/item/5ed234cac2a9a83be5882716.png" alt=""></p><p>​                            （图中红线1段需要用绿色线连接，连接后，后面一个2变为1）</p><p>​                                （另一种情况同理）</p><p>​                    4：如果一个为1，一个为2</p><p>​                        那么这个要注意，不能盲目的直接相连，要确保这是最后一个可行的格子时才能相连</p><p>​                        相当于减去一个1，一个2</p><p><img src="https://pic.downk.cc/item/5ed234dcc2a9a83be58841bd.png" alt=""></p><p>​                    （如图示，如果不是最后一个可行格会导致提前闭合）</p><p>​            状态转移的过程之后还有两个重要的部分</p><p>​                    1，四进制运算转移：如何找到B1，B2呢，在程序中我们肯定要枚举每一列，那么枚举到的</p><p>​                            每一列即是关键格的上方的一段关键轮廓线，那么B2很容易想到</p><p>​                            直接让当前状态右移2*当前列数即可</p><p>​                            那么B1呢？很容易看出，B1就是B2前面的一段，所以当前状态右移2*（当前列数-1）</p><p>​                            即可，当然别忘了都要对4取余才能得到是什么状态的插头在那个位置上</p><p>​                        在增加，减少插头的时候，我们可以初始化一个数组来辅助我们进行增加，减少</p><p>​                            （数组越靠左，位数越大，代表图中靠右的部分）</p><p>​                    2，HASH TABLE</p><p>​                            因为如果直接进行的话，可以看到需要3维数组才能完美的进行转移，可是3维</p><p>​                            需要的空间过于庞大，很容易就会炸空间，所以我们需要HASH TABLE要帮助我们</p><p>​                            进行转移，这里使用的是链式的HASH，构造中用取余+1的方式来求的位置</p><p>​                            如果不熟悉HASH的建议先去看看数据结构的哈希表再来理解，或者跳过此部分</p><p> AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIMIT = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HAS = <span class="number">299989</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;                                                </span><br><span class="line"><span class="keyword">int</span> e1, e2, last, now;                                    </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;                                            </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">15</span>][<span class="number">15</span>];                                        </span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">15</span>];                                            </span><br><span class="line"><span class="keyword">int</span> total[<span class="number">2</span>];                                            </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> js[<span class="number">2</span>][LIMIT];                                    </span><br><span class="line"><span class="keyword">int</span> h[<span class="number">300005</span>], a[<span class="number">2</span>][LIMIT], ne[LIMIT];                     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> zt, <span class="keyword">long</span> <span class="keyword">long</span> num)</span>                            </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = zt % HAS + <span class="number">1</span>;                            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[temp];i;i=ne[i])                        </span><br><span class="line">        <span class="keyword">if</span> (a[now][i] == zt)                            </span><br><span class="line">        &#123;</span><br><span class="line">            js[now][i] += num;                            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;                                                </span><br><span class="line">    ne[++total[now]] = h[temp];                            </span><br><span class="line">    h[temp] = total[now];                                </span><br><span class="line">    a[now][total[now]] = zt;                            </span><br><span class="line">    js[now][total[now]] = num;                            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;                                                            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)                                                    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = getchar();                                            </span><br><span class="line">            <span class="keyword">while</span> (ch != <span class="string">&#x27;*&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;.&#x27;</span>)                                    </span><br><span class="line">                ch = getchar();                                                </span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>)                                                    </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="number">1</span>;                                                </span><br><span class="line">                e1 = i;                                                        </span><br><span class="line">                e2 = j;                                                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    bin[<span class="number">0</span>] = <span class="number">1</span>;                                                                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++)</span><br><span class="line">        bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">2</span>;                                            </span><br><span class="line">    total[now] = <span class="number">1</span>;                                                        </span><br><span class="line">    js[now][<span class="number">1</span>] = <span class="number">1</span>;                                                            </span><br><span class="line">    a[now][<span class="number">1</span>] = <span class="number">0</span>;                                                            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)                                            </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= total[now]; j++)                            </span><br><span class="line">            a[now][j] &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)                                        </span><br><span class="line">        &#123;</span><br><span class="line">            last = now;                                                        </span><br><span class="line">            now ^= <span class="number">1</span>;                                                        </span><br><span class="line">            <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));                                         </span><br><span class="line">            total[now] = <span class="number">0</span>;                                                    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= total[last]; k++)                            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> zt = a[last][k];                                        </span><br><span class="line">                <span class="keyword">int</span> b1 = (zt &gt;&gt; (j * <span class="number">2</span> - <span class="number">2</span>)) % <span class="number">4</span>;                            </span><br><span class="line">                <span class="keyword">int</span> b2 = (zt &gt;&gt; (j * <span class="number">2</span>)) % <span class="number">4</span>;                                </span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> num = js[last][k];                                </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">map</span>[i][j])                                                </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!b1 &amp;&amp; !b2)                                            </span><br><span class="line">                        ins(zt, num);                                         </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!b1 &amp;&amp; !b2)                                        </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[i + <span class="number">1</span>][j] &amp;&amp; <span class="built_in">map</span>[i][j + <span class="number">1</span>])                        </span><br><span class="line">                        ins(zt + bin[j - <span class="number">1</span>] + <span class="number">2</span> * bin[j], num);                 </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!b1 &amp;&amp; b2)                                            </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[i][j + <span class="number">1</span>])                                        </span><br><span class="line">                        ins(zt, num);                                        </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[i + <span class="number">1</span>][j])                                        </span><br><span class="line">                        ins(zt - bin[j] * b2 + bin[j - <span class="number">1</span>] * b2, num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (b1 &amp;&amp; !b2)                                            </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[i][j + <span class="number">1</span>])                                    </span><br><span class="line">                        ins(zt - bin[j - <span class="number">1</span>] * b1 + bin[j] * b1, num);        </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[i + <span class="number">1</span>][j])                                    </span><br><span class="line">                        ins(zt, num);                                </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">1</span> &amp;&amp; b2 == <span class="number">1</span>)                                </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> kl = <span class="number">1</span>;                                                </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = j + <span class="number">1</span>; t &lt;= M; t++)                    </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((zt &gt;&gt; (t * <span class="number">2</span>)) % <span class="number">4</span> == <span class="number">1</span>)                    </span><br><span class="line">                            kl++;                                            </span><br><span class="line">                        <span class="keyword">if</span> ((zt &gt;&gt; (t * <span class="number">2</span>)) % <span class="number">4</span> == <span class="number">2</span>)                        </span><br><span class="line">                            kl--;                                            </span><br><span class="line">                        <span class="keyword">if</span> (!kl)                                            </span><br><span class="line">                        &#123;</span><br><span class="line">                            ins(zt - bin[j] - bin[j - <span class="number">1</span>] - bin[t], num);</span><br><span class="line">                            <span class="keyword">break</span>;                                        </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">2</span> &amp;&amp; b2 == <span class="number">2</span>)                                    </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> kl = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = j - <span class="number">2</span>; t &gt;= <span class="number">0</span>; t--)                            </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((zt &gt;&gt; (t * <span class="number">2</span>)) % <span class="number">4</span> == <span class="number">1</span>)                            </span><br><span class="line">                            kl--;</span><br><span class="line">                        <span class="keyword">if</span> ((zt &gt;&gt; (t * <span class="number">2</span>)) % <span class="number">4</span> == <span class="number">2</span>)                            </span><br><span class="line">                            kl++;</span><br><span class="line">                        <span class="keyword">if</span> (!kl)                                                </span><br><span class="line">                        &#123;</span><br><span class="line">                            ins(zt + bin[t] - <span class="number">2</span> * bin[j] - <span class="number">2</span> * bin[j - <span class="number">1</span>], num);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">2</span> &amp;&amp; b2 == <span class="number">1</span>)                                    </span><br><span class="line">                    ins(zt - <span class="number">2</span> * bin[j - <span class="number">1</span>] - bin[j], num);                        </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == e1 &amp;&amp; j == e2)                                    </span><br><span class="line">                    ans += num;                                                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    HDU 1693</p><h1 id="Eat-the-Trees"><a href="#Eat-the-Trees" class="headerlink" title="Eat the Trees"></a>Eat the Trees</h1><p>Time limit    2000 ms    Memory limit    32768 kB</p><p> Most of us know that in the game called DotA(Defense of the Ancient), Pudge is a strong hero in the first period of the game. When the game goes to end however, Pudge is not a strong hero any more.<br>So Pudge’s teammates give him a new assignment—Eat the Trees!</p><p>The trees are in a rectangle N * M cells in size and each of the cells either has exactly one tree or has nothing at all. And what Pudge needs to do is to eat all trees that are in the cells.<br>There are several rules Pudge must follow:<br>I. Pudge must eat the trees by choosing a circuit and he then will eat all trees that are in the chosen circuit.<br>II. The cell that does not contain a tree is unreachable, e.g. each of the cells that is through the circuit which Pudge chooses must contain a tree and when the circuit is chosen, the trees which are in the cells on the circuit will disappear.<br>III. Pudge may choose one or more circuits to eat the trees.</p><p>Now Pudge has a question, how many ways are there to eat the trees?<br>At the picture below three samples are given for N = 6 and M = 3(gray square means no trees in the cell, and the bold black line means the chosen circuit(s))</p><p><img src="https://vj.z180.cn/e09a280a0d56b1d7a8752053e38fc553?v=1590792032" alt="img"></p><p>Input</p><p>The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.<br>For each case, the first line contains the integer numbers N and M, 1&lt;=N, M&lt;=11. Each of the next N lines contains M numbers (either 0 or 1) separated by a space. Number 0 means a cell which has no trees and number 1 means a cell that has exactly one tree.</p><p>Output</p><p>For each case, you should print the desired number of ways in one line. It is guaranteed, that it does not exceed 2 63 – 1. Use the format in the sample. </p><p>​    题意： 详细的就不翻译了（帕吉没那么弱的好吗。。。）</p><p>​                大意就是给定一个图，分为能走的地方为1，不能走的地方为0</p><p>​                要从中找出尽可能多的路径形成一个或多个环，并且走遍了每一个1的位置</p><p>​    分析：直接暴力DFS遍历？</p><p>​                看这内存貌似不允许，而且一个图有多种情况，DFS的判断也无从下手，而且时间允许你遍历那                么多吗？显然不可能</p><p>​                重点：数据范围，只有1&lt;=N,M&lt;=11的范围，多么心动啊，一看就是状压DP</p><p>​                又跟这种连通图有关系，那么，插头DP没跑了</p><p>​                这道题要求的只是不同的环，那就好办了，将轮廓线的状态压为二进制</p><p>​                为什么是二进制呢，因为只要求是环就可以，那么我们只需要考虑让他成多个或者一个环就可以</p><p>​                没有一条要求的必须的路径，所以不用考虑是出还是入，有插头就是1，没插头就是0</p><p>​                当然转移时只需用到关键轮廓线的状态就好</p><p>​                定义左边的关键轮廓线状态为B1，上边的的关键轮廓线状态为B2</p><p>​                    那么继续考虑的就是状态的转移了</p><p>​                    （1）当地图为 0</p><p>​                                地图为0代表地图此路不通，那么只有B1==B2==0时才可以转移</p><p>​                                转移完啥都没多，啥都没少</p><p>​                                所以很容易想到（先自己想，之后给出总结）</p><p>​                            以下均为当地图不为 0</p><p>​                    （2）当B1==B2==0时</p><p>​                                两插头都为零，那么这个格子想转移就需要他右边的和下边的格子都为1才可以</p><p>​                                转移完之后，多加了一个右插头，一个下插头</p><p>​                    （3）当B1==1，B2==0或者B2==1，B1==0时</p><p>​                                那么，很容易想到，那B1==1的情况举例</p><p>​                                当这个格子右边的格子可以走时，直接走过去，右插头连过去变为右插头，直接转移</p><p>​                                当这个格子下边的格子可以走时，拐下去，右插头连过去变为下插头，</p><p>​                                                    相当于减少一个右插头，多加一个下插头转移</p><p>​                    （4）当B1==B2==1时</p><p>​                                这两个插头直接相连，无需考虑多余，因为题中也要求多环的情况</p><p>​                                相当于什么呢？对，就是减少了一个右插头一个下插头</p><p>​                转移方面想好了，只差最后一步了</p><p>​                    那就是保存方面，在转移保存上，因为压缩为二进制，那么直接使用三维数组即可完成</p><p>​                    DP（i，j，zt）</p><p>​                                    i，j 代表考虑到哪个格子</p><p>​                                    zt 代表考虑这个格子的轮廓线的哪种状态</p><p>​                    老朋友：BIN数组，来辅助我们对二进制进行操作</p><p>​                    取状态的时候，只需要对应的zt（当前状态）&amp;bin（j）即可得到B2</p><p>​                                                那么B1就很容易，为：zt&amp;bin（j - 1）</p><p>​                    </p><p>​                        以下给转移方程中看懂上述思路，但不会代码的朋友</p><p>​                            首先右插头永远在二进制偏右侧，下插头永远在右插头的二进制位置的左侧</p><p>​                            那么已知 j 代表为下插头的位置，想要删除这个下插头就直接 zt - bin（j）即可</p><p>​                            加上也同理，将减改为加</p><p>​                            那么删掉右插头呢，那右插头对应的二进制位就是 j - 1</p><p>​                            那么很容易想到了吧，zt-bin（j - 1）就删掉了</p><p>​                            加上也同理，再回头看看思路，是不是会写了呢？</p><p>​    AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">15</span>][<span class="number">15</span>][<span class="number">1</span> &lt;&lt; <span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++)</span><br><span class="line">        bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][M][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> limit = bin[M + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> zt = <span class="number">0</span>; zt &lt;= limit; zt++)</span><br><span class="line">                dp[i][<span class="number">0</span>][zt &lt;&lt; <span class="number">1</span>] = dp[i - <span class="number">1</span>][M][zt];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)    </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> zt = <span class="number">0</span>; zt &lt;= limit; zt++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> b1 = zt &amp; bin[j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> b2 = zt &amp; bin[j];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> num = dp[i][j - <span class="number">1</span>][zt];</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">map</span>[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!b1 &amp;&amp; !b2)</span><br><span class="line">                            dp[i][j][zt] += num;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!b1 &amp;&amp; !b2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[i + <span class="number">1</span>][j] &amp;&amp; <span class="built_in">map</span>[i][j + <span class="number">1</span>])</span><br><span class="line">                            dp[i][j][zt + bin[j - <span class="number">1</span>] + bin[j]] += num;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!b1 &amp;&amp; b2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[i][j + <span class="number">1</span>])</span><br><span class="line">                            dp[i][j][zt] += num;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[i + <span class="number">1</span>][j])</span><br><span class="line">                            dp[i][j][zt + bin[j - <span class="number">1</span>] - bin[j]] += num;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (b1 &amp;&amp; !b2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[i][j + <span class="number">1</span>])</span><br><span class="line">                            dp[i][j][zt + bin[j] - bin[j - <span class="number">1</span>]] += num;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[i + <span class="number">1</span>][j])</span><br><span class="line">                            dp[i][j][zt] += num;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j][zt - bin[j - <span class="number">1</span>] - bin[j]] += num;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++temp &lt;&lt; <span class="string">&quot;: There are &quot;</span> &lt;&lt; dp[N][M][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; ways to eat the trees.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      10-插头
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="10-插头" scheme="http://yoursite.com/tags/10-%E6%8F%92%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>9-状压+区间</title>
    <link href="http://yoursite.com/2020/08/03/9-%E7%8A%B6%E5%8E%8B-%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2020/08/03/9-%E7%8A%B6%E5%8E%8B-%E5%8C%BA%E9%97%B4/</id>
    <published>2020-08-03T03:35:06.000Z</published>
    <updated>2020-08-08T10:34:31.476Z</updated>
    
    <content type="html"><![CDATA[<p>LUOGU P3092</p><h1 id="No-Change-G"><a href="#No-Change-G" class="headerlink" title="No Change G"></a>No Change G</h1><p>时间限制<strong>1.00s</strong>内存限制<strong>125.00MB<em>**</em></strong></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John is at the market to purchase supplies for his farm. He has in his pocket K coins (1 &lt;= K &lt;= 16), each with value in the range 1..100,000,000. FJ would like to make a sequence of N purchases (1 &lt;= N &lt;= 100,000), where the ith purchase costs c(i) units of money (1 &lt;= c(i) &lt;= 10,000). As he makes this sequence of purchases, he can periodically stop and pay, with a single coin, for all the purchases made since his last payment (of course, the single coin he uses must be large enough to pay for all of these). Unfortunately, the vendors at the market are completely out of change, so whenever FJ uses a coin that is larger than the amount of money he owes, he sadly receives no changes in return!</p><p>Please compute the maximum amount of money FJ can end up with after making his N purchases in sequence. Output -1 if it is impossible for FJ to make all of his purchases.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>* Line 1: Two integers, K and N.</p><p>* Lines 2..1+K: Each line contains the amount of money of one of FJ’s coins.</p><p>* Lines 2+K..1+N+K: These N lines contain the costs of FJ’s intended purchases.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>* Line 1: The maximum amount of money FJ can end up with, or -1 if FJ cannot complete all of his purchases.</p><p>​    题意：有K个硬币，1&lt;=K&lt;=16，面值在100 000 00以内</p><p>​                要买N个物品，1&lt;=N&lt;=100000</p><p>​                现在商店的收银机坏了，所以如果付钱多了没有找零</p><p>​                N个物品只能顺序购买</p><p>​                问：买完之后最多省多少钱</p><p>​    分析：这数据范围到16就知道需要用到状压DP，那么二进制状态很容易想到1代表这个币用了</p><p>​                那么设DP数组（1&lt;&lt;20）为了防止溢出开大些，表示这个状态顺序最多买多少商品</p><p>​                再用sum数组保存前 i 个物品总价值是多少</p><p>​                那么DP数组怎么进行转移呢？比如状态是1111，那么可转移的状态就是1110 1101 1011 0111</p><p>​                每次只转移一位以方便转移</p><p>​                那么DP方程很明显（注意DP是可买的最多的个数）</p><p>​                DP（i）=    max（DP（ i ），find（sum（dp（ i ^ (1&lt;&lt;( j - 1 ) ））+ a[ j ] ））</p><p>​                i 为要转移的状态，j 枚举考虑的第几个硬币</p><p>​                即转移前状态可以买到的最大个数的值，加上我转移到的状态多出来的钱数</p><p>​                find函数用二分法找这个钱数转移完之后买完了多少商品</p><p>​                然后跟原来取大者</p><p>​                答案即为DP（ i ）== N的时候，所有物品都已经被买完</p><p>​                用 all 函数来找买完之后的状态没有用到的钱，所有取最大</p><p>​                如果所有DP值都不等于N，那么无法买完，输出 - 1</p><p>​    AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> K, N;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>], b[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">100005</span>], dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> ans, flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = N, mid, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= sum[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++)</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))) == <span class="number">0</span>)</span><br><span class="line">            res += a[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; K &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; K); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">find</span>(sum[dp[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))]] + a[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; K); i++)</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == N)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, all(i));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LUOGU CF607B</p><h1 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h1><p>时间限制<strong>2.00s</strong>题目描述</p><p>Genos recently installed the game Zuma on his phone. In Zuma there exists a line of n<em>n</em> gemstones, the i<em>i</em> -th of which has color c_{i}<em>c**i</em> . The goal of the game is to destroy all the gemstones in the line as quickly as possible.</p><p>In one second, Genos is able to choose exactly one continuous substring of colored gemstones that is a palindrome and remove it from the line. After the substring is removed, the remaining gemstones shift to form a solid line again. What is the minimum number of seconds needed to destroy the entire line?</p><p>Let us remind, that the string (or substring) is called palindrome, if it reads same backwards or forward. In our case this means the color of the first gemstone is equal to the color of the last one, the color of the second gemstone is equal to the color of the next to last and so on.</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of input contains a single integer n<em>n</em> ( 1&lt;=n&lt;=5001&lt;=<em>n</em>&lt;=500 ) — the number of gemstones.</p><p>The second line contains n<em>n</em> space-separated integers, the i<em>i</em> -th of which is c_{i}<em>c**i</em> ( 1&lt;=c_{i}&lt;=n1&lt;=<em>c**i</em>&lt;=<em>n</em> ) — the color of the i<em>i</em> -th gemstone in a line.</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>Print a single integer — the minimum number of seconds needed to destroy the entire line.内存限制<strong>500.00MB</strong></p><p>​    题意：给定一排数字，可以一次消掉一个回文的数字串，问最少消几次可以全部消完</p><p>​    分析：这很明显是一个区间DP，从时间和数据范围上来看也不需要进行四边形不等式优化</p><p>​                但关键是初始化</p><p>​                但其实样例也给出了提示</p><p>​                    样例一：3</p><p>​                                    1 2 1</p><p>​                    那么很容易想到如果（i，j）为相邻的数，且a（ i ）==a（ j ） 时dp（ i，j ）= 1</p><p>​                    样例三：7</p><p>​                                    1 4 4 2 3 2 1</p><p>​                    可以通过这个样例得出一个特殊的转移方程</p><p>​                    即a（ i ）== a（ j ）时，dp（ i，j ）=dp（ i+1，j-1 ）</p><p>​                    那么如果上述都不符合就要枚举最优分界点，转移方程也很容易想到是</p><p>​                    dp（ i，j ）= min（dp（ i，j ），dp（ i，k ）+ dp（ k+1 ，j））；</p><p>​                    那么使用样例1给出的初始化方法和样例三给出的转移时的特殊方法得</p><p>​        AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][i + <span class="number">1</span>] = <span class="number">1</span> + (a[i] != a[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">3</span>; len &lt;= n; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      9-状压+区间
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="9-状压+区间" scheme="http://yoursite.com/tags/9-%E7%8A%B6%E5%8E%8B-%E5%8C%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>8-状压</title>
    <link href="http://yoursite.com/2020/08/03/8-%E7%8A%B6%E5%8E%8B/"/>
    <id>http://yoursite.com/2020/08/03/8-%E7%8A%B6%E5%8E%8B/</id>
    <published>2020-08-03T03:34:59.000Z</published>
    <updated>2020-08-08T10:34:35.295Z</updated>
    
    <content type="html"><![CDATA[<p>LUOGU P1879</p><h1 id="Corn-Fields-G"><a href="#Corn-Fields-G" class="headerlink" title="Corn Fields G"></a>Corn Fields G</h1><p>​        时间限制<strong>1.00s</strong>内存限制<strong>125.00MB</strong></p><p>​        Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p><p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个整数M和N，用空格隔开。</p><p>第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即牧场分配总方案数除以100,000,000的余数。</p><p>题意：有一块长方形牧场，要在上面种草，但是奶牛们只喜欢自己吃一片草地，不喜欢自己的跟别人的            连起来，给出草地状态：1代表可以种草，0代表不可以种草，问有几种草的方案，不限牛数</p><p>​            完全不种草也算一种方案</p><p>​            解：注意草地大小最多为15*15，但是如果使用DFS时间复杂度会上天，并且内存不够，并且其中</p><p>​                    的判断状态，记录也都很麻烦</p><p>​                    所以这就要使用到状压DP，状压DP首先作为一个DP，下一个状态只与上一个状态有关</p><p>​                    所以大大减少了遍历的时间，其次，利用二进制的方法排除了很多不必要的试探</p><p>​                    首先，我们可以将题目中给出来的草场状态用二进制初始化压缩，方便后续的判断</p><p>​                    然后我们设定DP（i，j）i 表示我们现在考虑的行数，j 表示考虑的状态</p><p>​                    然后继续用 flag 数组排除掉考虑的情况有相邻草地的情况（左右草地）</p><p>​                    那么我们一共有多少状态呢，15*15的草地，那么因为状态压缩的特殊性：</p><p>​                    即，只需考虑一行的情况</p><p>​                    所以DP数组的大小为（15，1&lt;&lt;20）</p><p>​                    15代表考虑行，最多有15行，1&lt;&lt;20为了开大一点防止内存溢出，实际只需使用1&lt;&lt;15</p><p>​                    可以看到，最多有1&lt;&lt;15的情况，则flag数组同理</p><p>​                    那么在初始化的时候，我们只需要用到左移，右移，异或等运算便可初始化完成</p><p>​                    所以冲突情况就是左移或右移之后再异或，如果不为零，则说明有草地相连</p><p>​                    题意给出全部荒废也是一种情况，所以初始化DP（0，0）为 1</p><p>​                    所以在接下来的庄毅过程中，只需要遍历M行</p><p>​                    枚举上一行的情况，枚举本行的情况，然后判断本行行的情况与草地是否相符</p><p>​                    用&amp;即可完成，如果有冲突，与草地状态异或后得到的不为本行情况</p><p>​                    然后再判断本行与上一行无上下相连（&amp;即可）</p><p>​                    转移方程为：DP（i，j）= DP（i，j）+DP（i-1，k）【别忘了取余！】</p><p>​                    最后的答案为DP（M）这一行的和【别忘了取余】</p><p> AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"><span class="keyword">int</span> Tboard[<span class="number">15</span>][<span class="number">15</span>];                                                    </span><br><span class="line"><span class="keyword">int</span> board[<span class="number">15</span>];                                                        </span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">15</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>];                                                </span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];                                                    </span><br><span class="line"><span class="keyword">int</span> ans;                                                            </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Tboard[i][j];                                    </span><br><span class="line">            board[i] = (board[i] &lt;&lt; <span class="number">1</span>) + Tboard[i][j];                </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); i++)                                </span><br><span class="line">        flag[i] = (!(i &amp; (i &lt;&lt; <span class="number">1</span>))) &amp;&amp; (!(i &amp; (i &gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;                                                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)                                    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; N); j++)                            </span><br><span class="line">            <span class="keyword">if</span> (flag[j] &amp;&amp; ((j &amp; board[i]) == j))                    </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; N); k++)                    </span><br><span class="line">                    <span class="keyword">if</span> ((k &amp; j) == <span class="number">0</span>)                                </span><br><span class="line">                        dp[i][j] = (dp[i][j]+dp[i - <span class="number">1</span>][k]) % mod;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); i++)                                </span><br><span class="line">        ans = (ans + dp[M][i]) % mod;                            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> LUOGU P2915</p><p>时间限制<strong>1.00s</strong>内存限制<strong>125.00MB</strong></p><h1 id="Mixed-Up-Cows-G"><a href="#Mixed-Up-Cows-G" class="headerlink" title="Mixed Up Cows G"></a>Mixed Up Cows G</h1><p>Each of Farmer John’s N (4 &lt;= N &lt;= 16) cows has a unique serial number S_i (1 &lt;= S_i &lt;= 25,000). The cows are so proud of it that each one now wears her number in a gangsta manner engraved in large letters on a gold plate hung around her ample bovine neck.</p><p>Gangsta cows are rebellious and line up to be milked in an order called ‘Mixed Up’. A cow order is ‘Mixed Up’ if the sequence of serial numbers formed by their milking line is such that the serial numbers of every pair of consecutive cows in line differs by more than K (1 &lt;= K &lt;= 3400). For example, if N = 6 and K = 1 then 1, 3, 5, 2, 6, 4 is a ‘Mixed Up’ lineup but 1, 3, 6, 5, 2, 4 is not (since the consecutive numbers 5 and 6 differ by 1).</p><p>How many different ways can N cows be Mixed Up?</p><p>For your first 10 submissions, you will be provided with the results of running your program on a part of the actual test data.</p><p>POINTS: 200</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>* Line 1: Two space-separated integers: N and K</p><p>* Lines 2..N+1: Line i+1 contains a single integer that is the serial number of cow i: S_i</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>* Line 1: A single integer that is the number of ways that N cows can be ‘Mixed Up’. The answer is guaranteed to fit in a 64 bit integer.</p><p>题意：有n有奶牛，第 i 头奶牛的编号是 si ，最近奶牛不开心（为什么这些动物一天到晚就不开心）</p><p>​            他们要排成乱序的队伍，给定一个 k 每相邻的两个牛之间的编号差要大于这个 k（严格大于）</p><p>​            问，有多少种可能的排序</p><p>​            重点：4&lt;=N&lt;=16</p><p>​            看到这数据范围，又是一个一看就要明显枚举的题，那肯定就要用到状压DP了</p><p>​            想到这里很简单，问题在于如何设计呢</p><p>​            首先照常使用DP（20，1&lt;&lt;20）来保存状态，前20代表当前考虑的第几个羊</p><p>​                                                                                        （注意这里不是编号，是第几个！）</p><p>​            那么怎么进行初始化，乍一看没有头绪，可是我们能想到的只有考虑第 i 只羊的时候</p><p>​            只有对应羊选上，只有这一种情况</p><p>​            那么这个唯一的想法作为初始化</p><p>​            那么答案最后要什么呢？</p><p>​            要的就是每一种的羊都选上，并且要每一种情况的最后一种状态那就是DP（i，(1&lt;&lt;N) -1）</p><p>​            最多一共就N种情况，那么全选的状态也就是移完 -1</p><p>​            那么最后要的答案是什么有了，就要开始考虑转移了</p><p>​            首先肯定要枚举当前考虑的情况，那么接下来如何设计转移呢</p><p>​            这里使用两个循环来枚举当前考虑的情况已经有的羊的第几只（不是编号，是第几只）</p><p>​            和要转移到的是第几只羊</p><p>​            那么原来的肯定要有，要转移到的肯定要现在还没有</p><p>​            那么用右移对应的只数 -1 位再与1异或就可以分辨出这一位是不是有羊</p><p>​            别忘了还要满足羊的编号（这里是编号）大于题目所给出的要求</p><p>​            那么最后附上转移方程DP（k，i |（1&lt;&lt;( k - 1 )））+= DP（j，i）</p><p>​            j 为当前考虑的羊的只数（不是编号）</p><p>​            k 为要转移到的羊的只数（不是编号）</p><p>​            转移完了的状态要把 k 加上，所以要用 i  | ( 1 &lt;&lt; ( k - 1 ) )来吧 k 状态添加进去</p><p>​        AC代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">20</span>][<span class="number">1</span>&lt;&lt;<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i][<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(id[j] - id[k]) &gt; K &amp;&amp; (i &gt;&gt; (j - <span class="number">1</span>) &amp; <span class="number">1</span>) &amp;&amp; !(i &gt;&gt; (k - <span class="number">1</span>) &amp; <span class="number">1</span>))</span><br><span class="line">                    dp[k][i | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))] += dp[j][i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        ans += dp[i][(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                            </p>]]></content>
    
    <summary type="html">
    
      8-状压
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="8-状压" scheme="http://yoursite.com/tags/8-%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>7-最小完全背包+换根DP</title>
    <link href="http://yoursite.com/2020/08/03/7-%E6%9C%80%E5%B0%8F%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-%E6%8D%A2%E6%A0%B9DP/"/>
    <id>http://yoursite.com/2020/08/03/7-%E6%9C%80%E5%B0%8F%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-%E6%8D%A2%E6%A0%B9DP/</id>
    <published>2020-08-03T03:34:44.000Z</published>
    <updated>2020-08-08T10:34:39.468Z</updated>
    
    <content type="html"><![CDATA[<p>HD 1114</p><h1 id="Piggy-Bank"><a href="#Piggy-Bank" class="headerlink" title="Piggy-Bank"></a>Piggy-Bank</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong></p><p>Problem Description</p><p>Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.</p><p>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!</p><p>Input</p><p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams.</p><p>Output</p><p>Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 110</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">30 50</span><br><span class="line">10 110</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">50 30</span><br><span class="line">1 6</span><br><span class="line">2</span><br><span class="line">10 3</span><br><span class="line">20 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The minimum amount of money in the piggy-bank is 60.</span><br><span class="line">The minimum amount of money in the piggy-bank is 100.</span><br><span class="line">This is impossible.</span><br></pre></td></tr></table></figure><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=Central+Europe+1999&amp;source=1&amp;searchmode=source">Central Europe 1999</a></p><p> 分析：一道很简单的完全背包，只不过要求求背包内的最小值</p><p>​                原完全背包转移方程：DP[ i ] = max ( DP[ i ] , DP[ i - Wight [ i ] ] +  Value [ i ] )</p><p>​                现转移方程：DP[ i ] = min ( DP[ i ] , DP[ i - Wight [ i ] ] +  Value [ i ] ) </p><p>AC 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> e, f, n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; e &gt;&gt; f &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line">        <span class="keyword">int</span> temp = f - e;</span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i]; j &lt;= temp; j++)</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], (dp[j - p[i]] + w[i]));</span><br><span class="line">        <span class="keyword">if</span> (dp[temp] != inf)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The minimum amount of money in the piggy-bank is &quot;</span> &lt;&lt; dp[temp] &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is impossible.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Radio-Prize"><a href="#Radio-Prize" class="headerlink" title="Radio-Prize"></a>Radio-Prize</h1><p><strong><em>\</em>Time Limit: 3000 MS  Memory Limit: 262144 K**</strong></p><p>All boring tree-shaped lands are alike, while all exciting tree-shaped lands are exciting in their own special ways.What makes Treeland more exciting than the other tree-shaped lands are the raddest radio hosts in the local area: Rootand Leaf. Every morning on FM 32:33 (repeating of course), Root and Leaf of The Full Depth Morning Show serveup the hottest celebrity gossip and traffic updates.</p><p>The region of Treeland is made of n<em>n</em> cities, connected by n - 1<em>n</em>−1 roads such that between every pair of cities there isexactly one simple path. The i<em>i</em>th road connects cities u_i<em>u**i</em> and v_i<em>v**i</em>, and has a toll of w_i<em>w**i</em>.</p><p>To reward their loyal listeners, The Full Depth Morning Show is giving away a number of travel packages! Root andLeaf will choose n - 1<em>n</em>−1 lucky residents from the city that sends them the most fan mail. Each of those residents thengets a distinct ticket to a different city in Treeland.</p><p>Each city in Treeland has its own tax on prizes: t_i<em>t**i</em>. Let d_{u,v}<em>d**u</em>,<em>v</em> be the sum of the tolls on each road on the only simplepath from city u<em>u</em> to v<em>v</em>. For a trip from city u<em>u</em> to city v<em>v</em>, the cost of that trip is then (t_u + t_v)d_{u,v}(<em>t**u</em>+<em>t**v</em>)<em>d**u</em>,<em>v</em>.</p><p>The shock jocks haven’t quite thought through how much their prize is worth. They need to prepare a report to theradio executives, to summarize the expected costs. For each city that could win the prize, what is the total cost ofpurchasing all the tickets?</p><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>The first line of input is a single integer n (1 \leq≤ n \leq≤ 100 000). The next line has n<em>n</em> space-separated integers t_i<em>t**i</em>(1 \leq t_i \leq 1 0001≤<em>t**i</em>≤1000), the tax in each city. The following n - 1<em>n</em>−1 lines each have 3 integers, u_i,v_i,w_i<em>u**i</em>,<em>v**i</em>,<em>w**i</em>, meaning the i<em>i</em>th roadconnects cities u_i<em>u**i</em> and v_i<em>v**i</em> (1 \leq u_i,v_i \leq n1≤<em>u**i</em>,<em>v**i</em>≤<em>n</em>), with a toll of w_i<em>w**i</em> (1 \leq w_i \leq 1 0001≤<em>w**i</em>≤1000).</p><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>Output n<em>n</em> lines. On the i<em>i</em>th line, output a single integer: the cost of purchasing tickets if city i wins the contest</p><h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 5 3 4 1</span><br><span class="line">1 2 2</span><br><span class="line">2 4 5</span><br><span class="line">4 3 3</span><br><span class="line">5 2 6</span><br></pre></td></tr></table></figure><h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">130</span><br><span class="line">159</span><br><span class="line">191</span><br><span class="line">163</span><br><span class="line">171</span><br></pre></td></tr></table></figure><h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">4 3 3 4 3 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 1</span><br><span class="line">1 4 6</span><br><span class="line">4 5 6</span><br><span class="line">6 4 2</span><br></pre></td></tr></table></figure><h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">209</span><br><span class="line">206</span><br><span class="line">232</span><br><span class="line">209</span><br><span class="line">336</span><br><span class="line">232</span><br></pre></td></tr></table></figure><p>​    </p><p>​    大意，有一个活动在一个岛上举行，这个岛上有 N 个城市，活动将选举出其中一个城市作为优胜</p><p>​                获得优胜的城市将给其他 N-1 个城市各选一个人来优胜城市游玩，费用由主办方承担</p><p>​                每个城市由自己的税收系数，每条道路之间由过路费，主办方承担路费，</p><p>​                收费方式如下：比如，从A城市到B城市</p><p>​                                            需要的费用为：两地税收系数和 * 两城市间道路所需总过路费（道路过路费的和）</p><p>​                主办方在举行活动时没有考虑到费用问题，现要计算，每一个城市获胜是，主办方所需付的费用</p><p>​    题解，乍一看应该是一个DFS的典型问题，这个思路没有问题，只是少了东西，如果单纯的DFS，</p><p>​                要考虑到，有可能在一个节点上会有分支，而分支行不通的可能，因为题目限定由N个节点，N-1个路</p><p>​                所以不会形成环图</p><p>​                还要考虑，题目中给出的节点数是：小于等于 10w</p><p>​                如果单纯对每个结点都进行单纯的DFS输出，虽然时间上限有3000ms，</p><p>​                但是大数的样例很难保证不会超时，所以需要借助到 DP 数组来简化DFS的计算</p><p>​                那么，我们不妨吧城市之间的联系看作一颗树，而不是图</p><p>​                那么有请小学二年级学过的换根DP</p><p>​                                换根DP基础思想：为了解决不定根的问题，</p><p>​                                                                即：要求输出所有根节点的所有情况时，使用换根DP</p><p>​                                方法：先随便选定一个根节点作为最初的根节点，进行一遍DFS与DP</p><p>​                                            然后用本次的结果再次进行DP，来得到其他根节点情况</p><p>​                首先说明需要保存的东西： t（M）用来保存题目中给的各地的税收</p><p>​                                                                sum用来保存，所有路费的总和</p><p>​                                                                sizen（M）用来保存以第 I 个节点为根节点时的子节点的个数</p><p>​                                                                sizev（M）用来保存以第 I 个节点为根节点时的子节点的值和</p><p>​                                                                sum_wij（M）用来保存从节点 I 到 J 所有的路费和</p><p>​                                                                sum_wijk（M）用来保存从节点 I 到 J 的路费和并乘 J 地的税收</p><p>​                                                                tree（M * 2）用来保存树的边及其权值</p><p>​                                                                node中的form代表从哪个节点来</p><p>​                                                                                next代表下一条要考虑的路径</p><p>​                                                                                value代表当前要考虑路径的权</p><p>​                                                                Head（M）用来保存当前考虑的路径所要达到的节点的</p><p>​                                                                                上一条可达到要到达节点的编号</p><p>​                                                                                Eg：当前4号节点通过路径3指向了2号节点</p><p>​                                                                                        5号节点想通过路径8指向2号节点</p><p>​                                                                                        为了可以顺利进行路径遍历，</p><p>​                                                                                        Head（2）为3，代表上一个到达节点2的为3</p><p>​                                                                                        在8号路完成之后，去3号路，让8号路next为3</p><p>​                                                                                        然后更新Head（2）为 8</p><p>​                接下来说明两个重要部分：dfs和DFS</p><p>​                            dfs对一个节点进行深度优先搜索，根据题意，要的时起始地点的税收和*路费和</p><p>​                            以样例一为例，说明如何进行一遍的dfs</p><p>​                                    考虑第一个城市获胜的一遍dfs</p><p>​                                                那么他就需要2X2+5X2（2到1）</p><p>​                                                                        2X7+4X7（4到1）</p><p>​                                                                        2X10+3X10（3到1）</p><p>​                                                                        2X8+1X8（5到1）</p><p>​                                                可以看到，前面都有一个2，提取公因式2，那么前半部分的和</p><p>​                                                                        即：2+7+10+8是什么呢？</p><p>​                                                                                    即：所有路径的长度</p><p>​                                                                                                用sum_wij维护这些值</p><p>​                                                                        转移方程就是sum_wij(x)+=sum_wij(F)+sizn(F) * V</p><p>​                                                            sum_wij(x)即考虑到第X个节点的总路径长度</p><p>​                                                            sum_wij(F)即到上一个节点所需的总路径长度</p><p>​                                                            sizn(F)这个节点之前有多少个节点</p><p>​                                                            V就是现在考虑的路径的权</p><p>​                                                            那么sizn(F)*V就很好理解，即有多少个节点要过这条路径</p><p>​                                                                            长度就应对应增加这么多</p><p>​                                                后面是对应路径长乘起始城市的对应税收</p><p>​                                                                        转移方程为sum_wijt(x)+=sum_wijt(F)+sizv(F)*V</p><p>​                                                                与上面的处理方法相似，可以类推</p><p>​                                                            sum_wijt(x)即考虑到第X个节点的总路径长度乘对应的累计T值</p><p>​                                                            sum_wijt(F)即上一个节点的路径长度乘对应的累计T值</p><p>​                                                            sum_sizv(F)即当前考虑的路径有多少城市的税收要收</p><p>​                                                            V仍为路费</p><p>​                                                    dfs结束</p><p>​                            DFS</p><p>​                                            在遍历完一遍之后我们已经有了到每个节点的每一个对应值</p><p>​                                            那么我们现在要求其他的就方便了很多，不需要再去执行更多的dfs            </p><p>​                                            Eg：我们已经求完了1为根节点的情况，求2为根节点的情况</p><p>​                                                    那么我们使用现成的sun_wij(F),sum_wijt(F)进行加工</p><p>​                                                    考虑节点2是，其F为1（样例1为例）</p><p>​                                                    那么我们有路径总和，路径总个数，呢么我们只需要</p><p>​                                                            1的总合减去2到1的部分，加上1到2的部分即可</p><p>​                                                    那么很明显转移方程为：</p><p>​                                            sum_wij(F)=sum_wij(x) - sizn(F) <em> V + (n-sizen(F)) </em> V</p><p>​                                                        即总和减去2到1的部分，即为1到2的部分，乘以当前路径（1到2）</p><p>​                                                        的路径权值，就是2节点为根节点的情况</p><p>​                                            sum_wijt(F)=sum_wij(x)-iszv(F) <em> V + (sum-sizev(F)) </em> V</p><p>​                                                        与上同理，类比即可</p><p>​                那么，到这里这个换根DP或者说叫DFS+回溯+DP这个连续剑已经结束了</p><p>​                            但是还有一个地方值得注意，那就是addnode增加树中或者图中的节点的方法</p><p>​                                        只保存这个节点从哪里出发，和这条路径考虑完，下一条是哪条的方法</p><p>​                                        在初始化节点时，就已经做完了回溯的工作，以至于在DFS和dfs的过程中</p><p>​                                        不需要再利用多余的方法去保存分支，而是直接初始化好了一条路线的方法</p><p>​                                        既省时间，有节省空间</p><p>​                            在dfs和DFS的过程中，其节点的移动始终都只用了一中方法，那就是查询</p><p>​                                    查询谁能到这个节点，通过的是哪条路，如果查询重复即：下一个与上一个相同</p><p>​                                                                                                                                        则直接找下一个</p><p>​                                    当这条路完成之后，走到这条路的next即下一个应该考虑的路的编号</p><p>​                                    在初始化时利用Head数组完成这样巧妙的初始化，使得dfs的回溯更加便利</p><p>​                            即，当前插入节点时，考虑Head（x），让next=Head（x）</p><p>​                                    在完成一次插入后，再让Head（x）变为当前序号，这样，</p><p>​                                    在下一次，又有去该节点的地方的时候，next就可以直接被初始化</p><p>​                                    为上一次的到这个节点的路径编号，</p><p>​                                    那么我这条路走完之后下一条走这个编号的路，完成了这样的保存之后</p><p>​                                    更新Head（x）为这次的编号，那么就相当于更新了考虑这个节点的时候先去</p><p>​                                    哪条路，再由这条路，引至下一条该走的路</p><p>​                                    来完成这个需要回溯但不需额外保存的方式</p><p> AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;tree[M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Head[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addnode</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[++counts].next = Head[x];</span><br><span class="line">    tree[counts].from = y;</span><br><span class="line">    tree[counts].value = v;</span><br><span class="line">    Head[x] = counts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sizn[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sizv[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum_wij[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum_wijt[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sizn[x] = <span class="number">1</span>;</span><br><span class="line">    sizv[x] = t[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[x]; i; i = tree[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> F = tree[i].from;</span><br><span class="line">        <span class="keyword">int</span> V = tree[i].value;</span><br><span class="line">        <span class="keyword">if</span> (F == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(F, x);</span><br><span class="line">        sizn[x] += sizn[F];</span><br><span class="line">        sizv[x] += sizv[F];</span><br><span class="line">        sum_wij[x] += sum_wij[F] + sizn[F] * V;</span><br><span class="line">        sum_wijt[x] += sum_wijt[F] + sizv[F] * V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[x]; i; i = tree[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> F = tree[i].from;</span><br><span class="line">        <span class="keyword">int</span> V = tree[i].value;</span><br><span class="line">        <span class="keyword">if</span> (F == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sum_wij[F] = sum_wij[x] - sizn[F] * V + (n - sizn[F]) * V;</span><br><span class="line">        sum_wijt[F] = sum_wijt[x] - sizv[F] * V + (sum - sizv[F]) * V;</span><br><span class="line">        DFS(F, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t[i];</span><br><span class="line">        sum += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addnode(u, v, w);</span><br><span class="line">        addnode(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">        temp += sum_wij[i] * t[i] + sum_wijt[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                            </p><p>​                                        </p><p>​                                                                                                            </p><p>​                                                                                            </p><p>​                                                                </p>]]></content>
    
    <summary type="html">
    
      7-最小完全背包+换根DP
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="7-最小完全背包+换根DP" scheme="http://yoursite.com/tags/7-%E6%9C%80%E5%B0%8F%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-%E6%8D%A2%E6%A0%B9DP/"/>
    
  </entry>
  
  <entry>
    <title>6-状压+最长上升子序列</title>
    <link href="http://yoursite.com/2020/08/03/6-%E7%8A%B6%E5%8E%8B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/08/03/6-%E7%8A%B6%E5%8E%8B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-08-03T03:34:31.000Z</published>
    <updated>2020-08-08T10:34:44.287Z</updated>
    
    <content type="html"><![CDATA[<p>HD 1074</p><h1 id="Doing-Homework"><a href="#Doing-Homework" class="headerlink" title="Doing Homework"></a>Doing Homework</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong></p><p>Problem Description</p><p>Ignatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test, 1 day for 1 point. And as you know, doing homework always takes a long time. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.</p><p>Input</p><p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case start with a positive integer N(1&lt;=N&lt;=15) which indicate the number of homework. Then N lines follow. Each line contains a string S(the subject’s name, each string will at most has 100 characters) and two integers D(the deadline of the subject), C(how many days will it take Ignatius to finish this subject’s homework).</p><p>Note: All the subject names are given in the alphabet increasing order. So you may process the problem much easier.</p><p>Output</p><p>For each test case, you should output the smallest total reduced score, then give out the order of the subjects, one subject in a line. If there are more than one orders, you should output the alphabet smallest one.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Computer 3 3</span><br><span class="line">English 20 1</span><br><span class="line">Math 3 2</span><br><span class="line">3</span><br><span class="line">Computer 3 3</span><br><span class="line">English 6 3</span><br><span class="line">Math 6 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">Computer</span><br><span class="line">Math</span><br><span class="line">English</span><br><span class="line">3</span><br><span class="line">Computer</span><br><span class="line">English</span><br><span class="line">Math</span><br><span class="line"></span><br><span class="line">Hint</span><br><span class="line">In the second test case, both Computer-&gt;English-&gt;Math and Computer-&gt;Math-&gt;English leads to reduce 3 points, but the </span><br><span class="line">word &quot;English&quot; appears earlier than the word &quot;Math&quot;, so we choose the first order. That is so-called alphabet order.</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>Author</p><p>Ignatius.L</p><p>​    分析：题意：现在有 N 门课的作业要交，但是都还没有完成，按字典序给定课程名称，</p><p>​                            需还有多少天上交，完成这门课的作业需要的时间，每超出一天则会在期末成绩少一分</p><p>​                            问：怎样做作业才可以使扣分最少，输出最少分数以及作业顺序（按字典顺序）</p><p>​                            重点：1&lt;=N&lt;=15</p><p>​                思想：懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵懵</p><p>​                            首先可以看出是一个DP问题，也有直觉可以使用贪心算法？</p><p>​                            但是在贪心过程中会出现很多问题，比如：要存的东西过多使用了一万个数组（不是）</p><p>​                            所以DP求解是比较方便的，因为重点：N 的数据量很小</p><p>​                            那么我们可以遍历每一种情况，找到最小值，输出。</p><p>​                            但是如果使用正常的DP会遇到一个很严重的问题：因为要使每一门课的每一种组合情况</p><p>​                                    都保存到，3门课还好，三维数组便可解决，但是15门课呢？</p><p>​                                    用15维数组吗？（要保存每一种情况）显然是不科学的</p><p>​                            那。。。。怎么办呢？</p><p>​                            头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃</p><p>​                            那么就有请小学二年级学过的状压DP登场！</p><p>​                            这个状态，要保存每一门课是否上过，那么我们使用二进制数来表示就再简便不过了</p><p>​                            以3门课举例，我们只需要1&lt;&lt;3这么多个数字就可以表示每一种状态</p><p>​                            001 010 011 100 101 110 111（哪一位数字为1，则哪一门课上过）</p><p>​                            这样一来，就算N==15，也只需要DP（1&lt;&lt;15）即可</p><p>​                            那我们如何转移呢？</p><p>​                            我们用 i 表示当前要考虑的状态是从哪来的</p><p>​                            用 j 表示我们当前考虑的课程</p><p>​                            用 DP 来保存当前状态超出天数的最小值</p><p>​                            用 PRE 来记录，这个状态是由哪个状态变过来最小的，来方便我们输出</p><p>​                            那么我们先来看：i &amp; (1 &lt;&lt; j ) ：这个可以判断什么呢？</p><p>​                                                        &amp; 此运算符在两个数对应二进制位都为 1 的时候才为 1.</p><p>​                                                        所以可以用来判断是不是又重复的作业，比如 001和 011 这两个状态</p><p>​                                                        显然不可共存</p><p>​                            然后使用一个中间变量，累加已有的状态的时间量和当前要考虑的时间量，</p><p>​                            并且做计算超出时间的工作，如果没超出则为 0 就好</p><p>​                            完成之后，中间变量的值便是多加了当前情况之后，超出的时间的值</p><p>​                            进行完之后进行转移：</p><p>​                            那么DP（ i | (1 &lt;&lt; j ) ）代表什么呢？</p><p>​                                            | 此运算符在两个数的二进制位中有一个为 1  就为 1</p><p>​                                            所以，就相当于在表示考虑过的作业的情况，比如前提 i == 001</p><p>​                                                                                                                        现在考虑为 j == 100</p><p>​                                            那么就可以表示DP（101），相当于前提和当前考虑组合起来</p><p>​                            那么怎么保证最小呢？</p><p>​                                            既然DP（ i | (1 &lt;&lt; j ) ）是由 i 转移得到的，那么比较也很明显了</p><p>​                                                        就是DP（ i | (1 &lt;&lt; j ) ）与 DP（ i ）+ 中间变量的值 取小者</p><p>​                            那么最后要的便是DP（（1 &lt;&lt; 课程数）- 1）了，因为如果再往下遍历</p><p>​                            以 3 为情况的话，便是 111 为前提了，也没有意义了</p><p>​                            最后，按照 PRE 数组递归输出即可</p><p>​                            整体时间复杂度过大，为：O（n²+2的n次方）</p><p>​                            但是数据量不大，，所以只用了 31MS</p><p>​        AC 代码如下：（头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃头秃）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> D, C;</span><br><span class="line">&#125;node[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        <span class="keyword">if</span> ((data &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span> &amp;&amp; (pre[data] &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    output(pre[data]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node[t].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; node[i].name &gt;&gt; node[i].D &gt;&gt; node[i].C;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; num); i++)</span><br><span class="line">            dp[i] = inf;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; num); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; k++)</span><br><span class="line">                    <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                        s += node[k].C;</span><br><span class="line">                s += node[j].C;</span><br><span class="line">                <span class="keyword">if</span> (s &gt; node[j].D)</span><br><span class="line">                    s = s - node[j].D;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[i | (<span class="number">1</span> &lt;&lt; j)] &gt; dp[i] + s)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i | (<span class="number">1</span> &lt;&lt; j)] = dp[i] + s;</span><br><span class="line">                    pre[i | (<span class="number">1</span> &lt;&lt; j)] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; num) - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        output((<span class="number">1</span> &lt;&lt; num) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HD 1087</p><h1 id="Super-Jumping-Jumping-Jumping"><a href="#Super-Jumping-Jumping-Jumping" class="headerlink" title="Super Jumping! Jumping! Jumping!"></a>Super Jumping! Jumping! Jumping!</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong></p><p>Problem Description</p><p>Nowadays, a kind of chess game called “Super Jumping! Jumping! Jumping!” is very popular in HDU. Maybe you are a good boy, and know little about this game, so I introduce it to you now.</p><p><img src="http://acm.hdu.edu.cn/data/images/1087-1.jpg" alt="img"></p><p>The game can be played by two or more than two players. It consists of a chessboard（棋盘）and some chessmen（棋子）, and all chessmen are marked by a positive integer or “start” or “end”. The player starts from start-point and must jumps into end-point finally. In the course of jumping, the player will visit the chessmen in the path, but everyone must jumps from one chessman to another absolutely bigger (you can assume start-point is a minimum and end-point is a maximum.). And all players cannot go backwards. One jumping can go from a chessman to next, also can go across many chessmen, and even you can straightly get to end-point from start-point. Of course you get zero point in this situation. A player is a winner if and only if he can get a bigger score according to his jumping solution. Note that your score comes from the sum of value on the chessmen in you jumping path.<br>Your task is to output the maximum value according to the given chessmen list.</p><p>Input</p><p>Input contains multiple test cases. Each test case is described in a line as follow:<br>N value_1 value_2 …value_N<br>It is guarantied that N is not more than 1000 and all value_i are in the range of 32-int.<br>A test case starting with 0 terminates the input and this test case is not to be processed.</p><p>Output</p><p>For each case, print the maximum according to rules, and one line one case.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 1 3 2</span><br><span class="line">4 1 2 3 4</span><br><span class="line">4 3 3 2 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>Author</p><p>lcy</p><p>​        分析：题意：有一个棋盘和棋子，要求从开始的棋子跳至比当前棋子的数字严格大于的棋子上，                                可以不相邻</p><p>​                    思路：典型的最长上升子序列问题</p><p>​                                用 DP （ i ）保存前（ i ）个数中严格上升的子序列的最大和</p><p>​                                当 i 处于边界时：DP（ i ）= a（ i ）</p><p>​                                转移时的方程：MAX（DP（ i ），DP（ i ）+ A（ j ））</p><p>​                    方法：枚举上下边界    </p><p>​        AC 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            dp[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[j] &amp;&amp; dp[i] &lt; dp[j] + a[i])</span><br><span class="line">                    dp[i] = dp[j] + a[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                </p>]]></content>
    
    <summary type="html">
    
      6-状压+最长上升子序列
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="6-状压+最长上升子序列" scheme="http://yoursite.com/tags/6-%E7%8A%B6%E5%8E%8B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>5-滚动数组+DFS和DP</title>
    <link href="http://yoursite.com/2020/08/03/5-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-DFS%E5%92%8CDP/"/>
    <id>http://yoursite.com/2020/08/03/5-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-DFS%E5%92%8CDP/</id>
    <published>2020-08-03T03:33:57.000Z</published>
    <updated>2020-08-08T10:34:49.258Z</updated>
    
    <content type="html"><![CDATA[<p>HD 1024</p><h1 id="Max-Sum-Plus-Plus"><a href="#Max-Sum-Plus-Plus" class="headerlink" title="Max Sum Plus Plus"></a>Max Sum Plus Plus</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong></p><p>Problem Description</p><p>Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.</p><p>Given a consecutive number sequence S<em>1</em>, S<em>2</em>, S<em>3</em>, S<em>4</em> … S<em>x</em>, … S<em>n</em> (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ S<em>x</em> ≤ 32767). We define a function sum(i, j) = S<em>i</em> + … + S<em>j</em> (1 ≤ i ≤ j ≤ n).</p><p>Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i<em>1</em>, j<em>1</em>) + sum(i<em>2</em>, j<em>2</em>) + sum(i<em>3</em>, j<em>3</em>) + … + sum(i<em>m</em>, j<em>m</em>) maximal (i<em>x</em> ≤ i<em>y</em> ≤ j<em>x</em> or i<em>x</em> ≤ j<em>y</em> ≤ j<em>x</em> is not allowed).</p><p>But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(i<em>x</em>, j<em>x</em>)(1 ≤ x ≤ m) instead. ^_^</p><p>Input</p><p>Each test case will begin with two integers m and n, followed by n integers S<em>1</em>, S<em>2</em>, S<em>3</em> … S<em>n</em>.<br>Process to the end of file.</p><p>Output</p><p>Output the maximal summation described above in one line.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 3 1 2 3</span><br><span class="line">2 6 -1 4 -2 3 -2 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">Hint</span><br><span class="line">Huge input, scanf and dynamic programming is recommended.</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>Author</p><p>JGShining（极光炫影）</p><p>分析：题意：将一个数组分为不相交的M段，使这M段加起来的和最大</p><p>​                可以从题意看出，这肯定是一道DP问题，是最大子段和的一个升级版</p><p>​                要划分段，那就用DP（i，j）表示前 j 个数划分为 i 段时候的最大值</p><p>​                    就会有两种情况：1，第 j 个元素被分到了第 i 段：dp（i，j）= dp（i，j - 1）+ a（j）</p><p>​                                                    2，第 j 个元素没有被分到第 i 段</p><p>​                                                                    那就说明，前 j - 1 个元素被分为了 i - 1 段，</p><p>​                                                                    那么至少要有 i - 1 个元素分为 i - 1段，至多有 j - 1个</p><p>​                                                                    所以不能简单的 dp（i，j）= dp（i - 1，j - 1）+ a（j）</p><p>​                                                                    要枚举 i - 1开始到 j - 1结束有多少分为 i - 1 段最大</p><p>​                                                                    所以应为 max（dp（i - 1，k）+a（j））i - 1&lt;= k &lt;=j - 1</p><p>​                单纯到这里，题目已经能够解出来了，但是，数据范围：n = 1e6，按以上 dp 想法，</p><p>​                                        时间复杂度为立方级即 O（n³）</p><p>​                                        而且。。m 只要稍稍大一点点，恐怕内存也不保。。。</p><p>​                优化：1，空间（滚动数组）</p><p>​                                    dp（i，j）要二维数组过于浪费，因为从上述来看，</p><p>​                                                dp的下一个数只与上一行与本行有关，其余的行数为多余，</p><p>​                                                            并且最后只要dp（m，n）</p><p>​                                    所以采用两个数组简单实现滚动数组的方法</p><p>​                                                dp1保存本次更新完毕的最大值，dp2保存上次更新的最大值</p><p>​                                                与二维数组效果一致，节约了内存</p><p>​                            2，时间</p><p>​                                    在循环过程中：第三层循环即 i - 1&lt;=k&lt;=j - 1这个寻找最大的段可以放到更新过程中</p><p>​                                    创建一个临时变量来完成，不需要再多加一层循环，所以时间复杂度O（n²）</p><p>​                综上：dp1（j）= max（dp1（j - 1）+ a（j），dp2（j -1）+ a（j））；</p><p>​                            中间设置变量使 dp2（j - 1）一直为更新过程中的最大值。</p><p>​    AC 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN = <span class="number">-0x3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> dp1[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> dp2[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> maxx;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp1));</span><br><span class="line">        <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp2));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxx = MIN;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp1[j] = <span class="built_in">max</span>(dp2[j - <span class="number">1</span>] + a[j], dp1[j - <span class="number">1</span>] + a[j]);</span><br><span class="line">                <span class="keyword">if</span> (maxx != MIN) dp2[j - <span class="number">1</span>] = maxx;</span><br><span class="line">                <span class="keyword">if</span> (dp1[j] &gt; maxx)maxx = dp1[j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp2[j - <span class="number">1</span>] = maxx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; maxx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p> HD 1069</p><h1 id="Monkey-and-Banana"><a href="#Monkey-and-Banana" class="headerlink" title="Monkey and Banana"></a>Monkey and Banana</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong></p><p>Problem Description</p><p>A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a tower and climb up to get its favorite food.</p><p>The researchers have n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.</p><p>They want to make sure that the tallest tower possible by stacking blocks can reach the roof. The problem is that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block because there has to be some space for the monkey to step on. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked.</p><p>Your job is to write a program that determines the height of the tallest tower the monkey can build with a given set of blocks.</p><p>Input</p><p>The input file will contain one or more test cases. The first line of each test case contains an integer n,<br>representing the number of different blocks in the following data set. The maximum value for n is 30.<br>Each of the next n lines contains three integers representing the values xi, yi and zi.<br>Input is terminated by a value of zero (0) for n.</p><p>Output</p><p>For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format “Case case: maximum height = height”.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10 20 30</span><br><span class="line">2</span><br><span class="line">6 8 10</span><br><span class="line">5 5 5</span><br><span class="line">7</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">3 3 3</span><br><span class="line">4 4 4</span><br><span class="line">5 5 5</span><br><span class="line">6 6 6</span><br><span class="line">7 7 7</span><br><span class="line">5</span><br><span class="line">31 41 59</span><br><span class="line">26 53 58</span><br><span class="line">97 93 23</span><br><span class="line">84 62 64</span><br><span class="line">33 83 27</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Case 1: maximum height &#x3D; 40</span><br><span class="line">Case 2: maximum height &#x3D; 21</span><br><span class="line">Case 3: maximum height &#x3D; 28</span><br><span class="line">Case 4: maximum height &#x3D; 342</span><br></pre></td></tr></table></figure><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=University+of+Ulm+Local+Contest+1996&amp;source=1&amp;searchmode=source">University of Ulm Local Contest 1996</a></p><p>​    分析：题意：有 N 块砖，每块砖的规格为：（xi，yi，zi），现在要将砖一块上放一块，能放上去的条件                    为：低面的长，宽都严格小于在下面的砖，问最高能搭多高</p><p>​                首先：一块砖只给出了三遍的数据，并没有给出他的底面必须为哪个面，所以要考虑到所有的情况                            可以将每一块砖的以三个面为低的三种情况都保存下来，因为每块砖有无穷块</p><p>​                            每块砖的三个属性用结构体数组保存很方便</p><p>​                            保存完之后，每一块砖都相当于只有一块了（因为要严格小于）</p><p>​                            接下来，用dp（x）来保存找到第 x 块砖的最大高度是多少</p><p>​                            那么，如何让程序能够一直往下一块找，直到找到最大的值呢？</p><p>​                            可以设计多组循环，但是时间复杂度肯定不允许</p><p>​                            所以要使用到深度优先搜索即 DFS</p><p>​                                    分为以下情况：（dp数组初始化为-1）</p><p>​                                                如果 dp（x）！= - 1：代表这个点已经进行过搜索，且当前值是搜索完的最大                                                        直接返回该值即可</p><p>​                                                如果 dp（x）= = - 1：代表该点还没有搜索过那么遍历每块砖，如果找到合适的</p><p>​                                                            就继续搜索下去，直到返回值</p><p>​                                                            返回了之后：有可能出现一个砖上能放多个其他砖的情况</p><p>​                                                            则，需要对 dp（x）：当前情况</p><p>​                                                            和 dfs（i）进行比较取大者</p><p>​                                    因为 DFS 中间使用了 DP 数组来保存被搜索过的砖，避免了 DFS递归 的缺点</p><p>​                                    所以，时间复杂度很小</p><p> AC 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[x] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[x];</span><br><span class="line">    dp[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">6</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[x].x &gt; a[i].x &amp;&amp; a[x].y &gt; a[i].y)</span><br><span class="line">            dp[x] = <span class="built_in">max</span>(dp[x], dfs(i));</span><br><span class="line">    dp[x] += a[x].z;</span><br><span class="line">    <span class="keyword">return</span> dp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            a[i * <span class="number">6</span>] = &#123; x,y,z &#125;;</span><br><span class="line">            a[i * <span class="number">6</span> + <span class="number">1</span>] = &#123; x,z,y &#125;;</span><br><span class="line">            a[i * <span class="number">6</span> + <span class="number">2</span>] = &#123; y,x,z &#125;;</span><br><span class="line">            a[i * <span class="number">6</span> + <span class="number">3</span>] = &#123; y,z,x &#125;;</span><br><span class="line">            a[i * <span class="number">6</span> + <span class="number">4</span>] = &#123; z,x,y &#125;;</span><br><span class="line">            a[i * <span class="number">6</span> + <span class="number">5</span>] = &#123; z,y,x &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">6</span>; i++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dfs(i));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; num++ &lt;&lt; <span class="string">&quot;: maximum height = &quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      5-滚动数组+DFS和DP
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="5-滚动数组+DFS和DP" scheme="http://yoursite.com/tags/5-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-DFS%E5%92%8CDP/"/>
    
  </entry>
  
  <entry>
    <title>4-博弈论</title>
    <link href="http://yoursite.com/2020/08/03/4-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/08/03/4-%E5%8D%9A%E5%BC%88%E8%AE%BA/</id>
    <published>2020-08-03T03:33:39.000Z</published>
    <updated>2020-08-08T10:34:53.591Z</updated>
    
    <content type="html"><![CDATA[<p>HD 1729</p><h1 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h1><p><strong><em>\</em>Time Limit: 5000/1000 MS (Java/Others)  Memory Limit: 65535/32768 K (Java/Others)**</strong></p><p>Problem Description</p><p>This game is a two-player game and is played as follows:</p><p>\1. There are n boxes; each box has its size. The box can hold up to s stones if the size is s.<br>\2. At the beginning of the game, there are some stones in these boxes.<br>\3. The players take turns choosing a box and put a number of stones into the box. The number mustn’t be great than the square of the number of stones before the player adds the stones. For example, the player can add 1 to 9 stones if there are 3 stones in the box. Of course, the total number of stones mustn’t be great than the size of the box.<br>4.Who can’t add stones any more will loss the game.</p><p>Give an Initial state of the game. You are supposed to find whether the first player will win the game if both of the players make the best strategy.</p><p>Input</p><p>The input file contains several test cases.<br>Each test case begins with an integer N, 0 &lt; N ≤ 50, the number of the boxes.<br>In the next N line there are two integer si, ci (0 ≤ ci ≤ si ≤ 1,000,000) on each line, as the size of the box is si and there are ci stones in the box.<br>N = 0 indicates the end of input and should not be processed.</p><p>Output</p><p>For each test case, output the number of the case on the first line, then output “Yes” (without quotes) on the next line if the first player can win the game, otherwise output “No”.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 0</span><br><span class="line">3 3</span><br><span class="line">6 2</span><br><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">6 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">Yes</span><br><span class="line">Case 2:</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%A1%B0%CD%F8%D0%C2%B6%F7%C6%D5%B1%AD%A1%B1%BA%BC%D6%DD%B5%E7%D7%D3%BF%C6%BC%BC%B4%F3%D1%A7%B3%CC%D0%F2%C9%E8%BC%C6%D1%FB%C7%EB%C8%FC&amp;source=1&amp;searchmode=source">“网新恩普杯”杭州电子科技大学程序设计邀请赛</a></p><p>​    分析：此题为ICG博弈，SG函数题</p><p>​                大意：有两个人玩游戏，有N个盒子，每个盒子给定容量S以及现有石子数C，接下来只能往盒子                            中放入1-C*C个石子，直到有人无法放入任何石子，游戏结束</p><p>​                那么我们先找出必败态，很明显，如果石子数C==容量S，那么肯定必败</p><p>​                那么如果我们假设现在石子数为Z，且Z为必败态，那么，Z应满足的的条件为</p><p>​                                                Z+Z x Z<S 和 （Z+1）+（Z+1）x（Z+1）>=S</p><p>​                那么，我们可以根据上式，计算出最大必败态 T</p><p>​                那么，明显可以得到，如果石子数C，满足T+1&lt;=C&lt;=S-1，则C为必胜态</p><p>​                那么，将会出现以下3种情况：C==T，C<T，C>T</p><p>​                            1：C==T，则当前为必败，返回0即可</p><p>​                            2：C&lt;T，那么我就可以认为，T为当前盒子最大容量，然后重复上述过程，</p><p>​                                    始终可以回到情况1和3</p><p>​                            3：C&gt;T，这时为必胜态，直接返回我们所需的对应的SG值即可，</p><p>​                                    即C的后继集合中最小的数，即：S-C</p><p>​                得出所有SG值之后，再通过尼姆博弈结论，得出答案即可</p><p>​    AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SG</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">sqrt</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (p + p * p &gt;= s)</span><br><span class="line">        p--;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; p)</span><br><span class="line">        <span class="keyword">return</span> s - c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SG(p, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;num) &amp;&amp; num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>  s, c;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;c);</span><br><span class="line">            ans ^= SG(s, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> (ans)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                </p><p> HD 2147</p><h1 id="kiki’s-game"><a href="#kiki’s-game" class="headerlink" title="kiki’s game"></a>kiki’s game</h1><p><strong><em>\</em>Time Limit: 5000/1000 MS (Java/Others)  Memory Limit: 40000/10000 K (Java/Others)**</strong></p><p>Problem Description</p><p>Recently kiki has nothing to do. While she is bored, an idea appears in his mind, she just playes the checkerboard game.The size of the chesserboard is n*m.First of all, a coin is placed in the top right corner(1,m). Each time one people can move the coin into the left, the underneath or the left-underneath blank space.The person who can’t make a move will lose the game. kiki plays it with ZZ.The game always starts with kiki. If both play perfectly, who will win the game?</p><p>Input</p><p>Input contains multiple test cases. Each line contains two integer n, m (0&lt;n,m&lt;=2000). The input is terminated when n=0 and m=0.</p><p>Output</p><p>If kiki wins the game printf “Wonderful!”, else “What a pity!”.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">5 4</span><br><span class="line">6 6</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">What a pity!</span><br><span class="line">Wonderful!</span><br><span class="line">Wonderful!</span><br></pre></td></tr></table></figure><p>Author</p><p>月野兔</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+2007-11++Programming+Contest&amp;source=1&amp;searchmode=source">HDU 2007-11 Programming Contest</a></p><p>分析：题意：有一枚硬币在棋盘的初始角（0，0）上，只能向右，下，右下走，直到无法移动，游戏结束</p><p>​            问，谁会获胜</p><p>​            那么我们可以使用dp数组打表来解决，即用dp打表判断谁会获胜</p><p>​    AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dirx[] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> diry[] = &#123; <span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2000</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2000</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + dirx[k];</span><br><span class="line">                <span class="keyword">int</span> y = j + diry[k];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!dp[x][y])</span><br><span class="line">                    dp[i][j] = dp[j][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n - <span class="number">1</span>][m - <span class="number">1</span>])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wonderful!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;What a pity!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    你以为到这里就完事了吗，没有，其实，打完表之后可以发现一个规律，</p><p>​                即：当n*m为偶数时候，Kiki会获胜</p><p>​                        当n*m为奇数的时候，Kiki会输</p><p>​    AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">        <span class="keyword">if</span> (n * m % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wonderful!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;What a pity!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      4-博弈论
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="4-博弈论" scheme="http://yoursite.com/tags/4-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>3-博弈论</title>
    <link href="http://yoursite.com/2020/08/03/3-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/08/03/3-%E5%8D%9A%E5%BC%88%E8%AE%BA/</id>
    <published>2020-08-03T03:33:35.000Z</published>
    <updated>2020-08-08T10:35:01.931Z</updated>
    
    <content type="html"><![CDATA[<p>HD 1536</p><h1 id="S-Nim"><a href="#S-Nim" class="headerlink" title="S-Nim"></a>S-Nim</h1><p> <strong><em>\</em>Time Limit: 5000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong> </p><p>Problem Description</p><p>Arthur and his sister Caroll have been playing a game called Nim for some time now. Nim is played as follows:<br> The starting position has a number of heaps, all containing some, not necessarily equal, number of beads.</p><p> The players take turns chosing a heap and removing a positive number of beads from it.</p><p> The first player not able to make a move, loses.</p><p>Arthur and Caroll really enjoyed playing this simple game until they recently learned an easy way to always be able to find the best move:</p><p> Xor the number of beads in the heaps in the current position (i.e. if we have 2, 4 and 7 the xor-sum will be 1 as 2 xor 4 xor 7 = 1).</p><p> If the xor-sum is 0, too bad, you will lose.</p><p> Otherwise, move such that the xor-sum becomes 0. This is always possible.</p><p>It is quite easy to convince oneself that this works. Consider these facts:</p><p> The player that takes the last bead wins.</p><p> After the winning player’s last move the xor-sum will be 0.</p><p> The xor-sum will change after every move.</p><p>Which means that if you make sure that the xor-sum always is 0 when you have made your move, your opponent will never be able to win, and, thus, you will win.</p><p>Understandibly it is no fun to play a game when both players know how to play perfectly (ignorance is bliss). Fourtunately, Arthur and Caroll soon came up with a similar game, S-Nim, that seemed to solve this problem. Each player is now only allowed to remove a number of beads in some predefined set S, e.g. if we have S =(2, 5) each player is only allowed to remove 2 or 5 beads. Now it is not always possible to make the xor-sum 0 and, thus, the strategy above is useless. Or is it?</p><p>your job is to write a program that determines if a position of S-Nim is a losing or a winning position. A position is a winning position if there is at least one move to a losing position. A position is a losing position if there are no moves to a losing position. This means, as expected, that a position with no legal moves is a losing position.</p><p>Input</p><p>Input consists of a number of test cases. For each test case: The first line contains a number k (0 &lt; k ≤ 100 describing the size of S, followed by k numbers si (0 &lt; si ≤ 10000) describing S. The second line contains a number m (0 &lt; m ≤ 100) describing the number of positions to evaluate. The next m lines each contain a number l (0 &lt; l ≤ 100) describing the number of heaps and l numbers hi (0 ≤ hi ≤ 10000) describing the number of beads in the heaps. The last test case is followed by a 0 on a line of its own.</p><p>Output</p><p>For each position: If the described position is a winning position print a ‘W’.If the described position is a losing position print an ‘L’. Print a newline after each test case.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2 2 5</span><br><span class="line">3</span><br><span class="line">2 5 12</span><br><span class="line">3 2 4 7</span><br><span class="line">4 2 3 7 12</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">3</span><br><span class="line">2 5 12</span><br><span class="line">3 2 4 7</span><br><span class="line">4 2 3 7 12</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LWW</span><br><span class="line">WWL</span><br></pre></td></tr></table></figure><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=Norgesmesterskapet+2004&amp;source=1&amp;searchmode=source">Norgesmesterskapet 2004</a></p><p>​        题意分析：同样是一道ICG博弈的内容，是尼姆博弈的升级（一点），区别在于可以拿走的数目</p><p>​                            是样例给出的固定个数，则，需要根据题目给出的数目来计算SG函数值，</p><p>​                            计算出后，根据尼姆博弈的结论，按查询进行计算输出即可。</p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> S[<span class="number">110</span>], n, NUM, ASK, SG[<span class="number">11000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(SG, <span class="number">0</span>, <span class="keyword">sizeof</span>(SG));</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">11000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[j] &gt; i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            vis[SG[i - S[j]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                SG[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; S[i];</span><br><span class="line">        sort(S, S + n);</span><br><span class="line">        getsg();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; NUM;</span><br><span class="line">        <span class="keyword">while</span> (NUM--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ASK;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ASK--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">                ans ^= SG[temp];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;W&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                            </p><p>HD 1564</p><h1 id="Play-a-game"><a href="#Play-a-game" class="headerlink" title="Play a game"></a>Play a game</h1><p> <strong><em>\</em>Time Limit: 1000/1000 MS (Java/Others)  Memory Limit: 32768/32768 K (Java/Others)**</strong> </p><p>Problem Description</p><p>New Year is Coming!<br>ailyanlu is very happy today! and he is playing a chessboard game with 8600.<br>The size of the chessboard is n*n. A stone is placed in a corner square. They play alternatively with 8600 having the first move. Each time, player is allowed to move the stone to an unvisited neighbor square horizontally or vertically. The one who can’t make a move will lose the game. If both play perfectly, who will win the game?</p><p>Input</p><p>The input is a sequence of positive integers each in a separate line.<br>The integers are between 1 and 10000, inclusive,(means 1 &lt;= n &lt;= 10000) indicating the size of the chessboard. The end of the input is indicated by a zero.</p><p>Output</p><p>Output the winner (“8600” or “ailyanlu”) for each input line except the last zero.<br>No other characters should be inserted in the output.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8600</span><br></pre></td></tr></table></figure><p>Author</p><p>ailyanlu</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=Happy+2007&amp;source=1&amp;searchmode=source">Happy 2007</a></p><p>​        分析：这是一道非常简单的，简单的令人发指的ICG博弈。。。。。。。。。</p><p>​                    无需用到SG函数。。。。。。。。。。。。。。。。。。。。。。。</p><p>​                    也不是什么类型的特殊博弈。。。。。。。。。。。。。。。。。。。</p><p>​        思考：8600先手出发。。。。。。。。。。。。。。。。。。。。。。。。。</p><p>​                    那么，只需知道，除了初始放石子的位置，还剩几个格子，便可知道</p><p>​                    谁会获胜。（奇数先手必胜，偶数先手必败）</p><p>​                    那么，只需算棋盘多大，然后判断奇偶即可。。。。。。。。。。。。</p><p>​    AC代码如下（没什么必要）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">        <span class="keyword">if</span> (n * n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;8600&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ailyanlu&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      3-博弈论
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="3-博弈论" scheme="http://yoursite.com/tags/3-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>2-博弈论</title>
    <link href="http://yoursite.com/2020/08/03/2-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/08/03/2-%E5%8D%9A%E5%BC%88%E8%AE%BA/</id>
    <published>2020-08-03T03:33:30.000Z</published>
    <updated>2020-08-08T10:35:06.890Z</updated>
    
    <content type="html"><![CDATA[<p>HDOJ  1524</p><h1 id="A-Chess-Game"><a href="#A-Chess-Game" class="headerlink" title="A Chess Game"></a>A Chess Game</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 2952  Accepted Submission(s): 1331<br>**</strong></p><p>Problem Description</p><p>Let’s design a new chess game. There are N positions to hold M chesses in this game. Multiple chesses can be located in the same position. The positions are constituted as a topological graph, i.e. there are directed edges connecting some positions, and no cycle exists. Two players you and I move chesses alternately. In each turn the player should move only one chess from the current position to one of its out-positions along an edge. The game does not end, until one of the players cannot move chess any more. If you cannot move any chess in your turn, you lose. Otherwise, if the misfortune falls on me… I will disturb the chesses and play it again.</p><p>Do you want to challenge me? Just write your program to show your qualification!</p><p>Input</p><p>Input contains multiple test cases. Each test case starts with a number N (1 &lt;= N &lt;= 1000) in one line. Then the following N lines describe the out-positions of each position. Each line starts with an integer Xi that is the number of out-positions for the position i. Then Xi integers following specify the out-positions. Positions are indexed from 0 to N-1. Then multiple queries follow. Each query occupies only one line. The line starts with a number M (1 &lt;= M &lt;= 10), and then come M integers, which are the initial positions of chesses. A line with number 0 ends the test case.</p><p>Output</p><p>There is one line for each query, which contains a string “WIN” or “LOSE”. “WIN” means that the player taking the first turn can win the game according to a clever strategy; otherwise “LOSE” should be printed.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2 1 2</span><br><span class="line">0</span><br><span class="line">1 3</span><br><span class="line">0</span><br><span class="line">1 0</span><br><span class="line">2 0 2</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2 0 1</span><br><span class="line">2 1 1</span><br><span class="line">3 0 1 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WIN</span><br><span class="line">WIN</span><br><span class="line">WIN</span><br><span class="line">LOSE</span><br><span class="line">WIN</span><br></pre></td></tr></table></figure><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=PKU+Monthly&amp;source=1&amp;searchmode=source">PKU Monthly</a></p><p>​        题解：题意为，有两个人进行ICG博弈，内容为在国际象棋棋盘中给出一副有向图，</p><p>​                    之后给出几个棋子的位置，问先手是必胜还是必败</p><p>​                    分析题意，一时间无从下手的感觉，但是他既然是一道ICG博弈题目，肯定要用到SG函数</p><p>​                    我们可求出的数值，只有对应棋子的可移动的放向的个数</p><p>​                                                        或者说是该有向图的该节点有几个后继节点</p><p>​                    那么我们以这个参数转换模型，相当与典型的尼姆博弈内容</p><p>​                    将一个棋子的后继节点数，看作尼姆博弈中一个堆的物品的数量，</p><p>​                    转化为尼姆博弈的结论：每堆物品数的异或值，如果不为0，则先手必胜</p><p>​                                                                                                        如果为0，则先手必败</p><p>​        C++ AC 代码如下；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> sg[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">1005</span>];</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">if</span> (sg[x] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> sg[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : edge[x])</span><br><span class="line">        vis[dfs(i)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            <span class="keyword">return</span> sg[x] = i;</span><br><span class="line">    <span class="keyword">return</span> sg[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge[i].<span class="built_in">clear</span>();</span><br><span class="line">            sg[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            <span class="keyword">int</span> y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; count;</span><br><span class="line">            <span class="keyword">while</span> (count--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">                edge[i].push_back(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; q &amp;&amp; q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">                ans ^= dfs(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;WIN&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LOSE&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HDOJ  1525</p><h1 id="Euclid’s-Game"><a href="#Euclid’s-Game" class="headerlink" title="Euclid’s Game"></a>Euclid’s Game</h1><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 6031  Accepted Submission(s): 2863<br>**</strong></p><p>Problem Description</p><p>Two players, Stan and Ollie, play, starting with two natural numbers. Stan, the first player, subtracts any positive multiple of the lesser of the two numbers from the greater of the two numbers, provided that the resulting number must be nonnegative. Then Ollie, the second player, does the same with the two resulting numbers, then Stan, etc., alternately, until one player is able to subtract a multiple of the lesser number from the greater to reach 0, and thereby wins. For example, the players may start with (25,7):</p><p>25 7<br>11 7<br>4 7<br>4 3<br>1 3<br>1 0</p><p>an Stan wins.</p><p>Input</p><p>The input consists of a number of lines. Each line contains two positive integers giving the starting two numbers of the game. Stan always starts.</p><p>Output</p><p>For each line of input, output one line saying either Stan wins or Ollie wins assuming that both of them play perfectly. The last line of input contains two zeroes and should not be processed.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">34 12</span><br><span class="line">15 24</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stan wins</span><br><span class="line">Ollie wins</span><br></pre></td></tr></table></figure><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=University+of+Waterloo+Local+Contest+2002.09.28&amp;source=1&amp;searchmode=source">University of Waterloo Local Contest 2002.09.28</a></p><p>​        分析：题意：一开始有两个整数，两名选手可以用大的数减去小的数的正整数倍数，</p><p>​                                用算出来的数替换大的数，如：25和7，可以用25-7*2=11</p><p>​                                                                                    用11替换25，变成11，7</p><p>​                                    知道有一个人可以将其中的一个数字减为0，则该选手获胜</p><p>​                                一道典型的找规律的ICG题目</p><p>​                                    分析：a均大于等于b时</p><p>​                                                当a==b，则先手必胜</p><p>​                                                当a%b==0，则先手必胜</p><p>​                                                当a&gt;=b*2时，因为此题为ICG博弈，选手智商破亿</p><p>​                                                                        所以，先手肯定能判断出（a%b，b）</p><p>​                                                                        是必胜还是必败</p><p>​                                                                        当为必败时，走到这点，让对手必败，则自己必胜</p><p>​                                                                        当为必胜时，走到（a%b+b，b），那么对手只能将</p><p>​                                                                                                （a%b，b）给自己</p><p>​                                                                所以，a&gt;=b*2时，先手必胜</p><p>​                                                当b&lt;a&lt;2*b时，则只能将情况变为（a-b,b）交换即可回到以上的模型</p><p>​                                                                则直接判断达到以上必胜点为哪位选手即可</p><p>​                                                                如果还是没有必胜出现，则继续为b&lt;a&lt;2*b的处理方法</p><p>​                        通过以上分析，则可判断所有情况下，谁会获胜</p><p>​            C++ AC 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m &amp;&amp; !n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">                swap(m, n);</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span> || m % n == <span class="number">0</span> || m / n &gt;= <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            m = m % n;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stan wins&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Ollie wins&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                </p>]]></content>
    
    <summary type="html">
    
      2-博弈论
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="2-博弈论" scheme="http://yoursite.com/tags/2-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>1-博弈论</title>
    <link href="http://yoursite.com/2020/08/03/1-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/08/03/1-%E5%8D%9A%E5%BC%88%E8%AE%BA/</id>
    <published>2020-08-03T03:33:26.000Z</published>
    <updated>2020-08-08T10:35:11.266Z</updated>
    
    <content type="html"><![CDATA[<p>HDOJ：1404</p><p>Problem Description</p><p> <strong><em>\</em>Time Limit: 4000/2000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong> </p><p>Digital deletions is a two-player game. The rule of the game is as following.</p><p>Begin by writing down a string of digits (numbers) that’s as long or as short as you like. The digits can be 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and appear in any combinations that you like. You don’t have to use them all. Here is an example:</p><p><img src="http://acm.hdu.edu.cn/data/images/1404-1.gif" alt="img"></p><p>On a turn a player may either:<br>Change any one of the digits to a value less than the number that it is. (No negative numbers are allowed.) For example, you could change a 5 into a 4, 3, 2, 1, or 0.<br>Erase a zero and all the digits to the right of it.<br>The player who removes the last digit wins.<br>The game that begins with the string of numbers above could proceed like this:</p><p><img src="http://acm.hdu.edu.cn/data/images/1404-2.gif" alt="img"></p><p>Now, given a initial string, try to determine can the first player win if the two players play optimally both.</p><p>Input</p><p>The input consists of several test cases. For each case, there is a string in one line.</p><p>The length of string will be in the range of [1,6]. The string contains only digit characters.</p><p>Proceed to the end of file.</p><p>Output</p><p>Output Yes in a line if the first player can win the game, otherwise output No.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">00</span><br><span class="line">1</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>Author</p><p>ZHENG, Jianqiang</p><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=Zhejiang+University+Local+Contest+2006+Preliminary&amp;source=1&amp;searchmode=source">Zhejiang University Local Contest 2006 Preliminary</a></p><p>Recommend</p><p>Ignatius.L</p><p>​    题目分析：（输入数字为字符型）</p><p>​        一串数字，两个人轮流行动，规则为：可以将该数字变为比他小的任意一个数字，</p><p>​                                                                        如果该数字是0，则可以选择将0右面无论多少个数清除。</p><p>​        如题目所示，此题为典型的 ICG 博弈问题，（不知道 ICG 博弈的自己百度）</p><p>​        但是，其不满足巴什，威佐夫，尼姆三大博弈的任何一个，虽然看起来像尼姆博弈，但并不满足</p><p>​        (因为多了规则)（以下均讨论先手人情况）</p><p>​        所以，此题需要通过 SG 函数来求得答案。（不知道 SG 函数是什么的自己百度）</p><p>​        首先，我们找出相关状态</p><p>​                必胜态有：0 2-9 10 12-19 21-29 ……………………………..</p><p>​                必败态有：1 11 20 ………………………………………………….</p><p>​        显然两态并没有明显规律，那么既然1为必败态，可以一步达到必败态的即为必胜态</p><p>​        考虑一个问题：1为必败态，那么10，100，101，10001这样的数字为必败态，因为根据规则</p><p>​        可以一步达到必败态，扔给对面。题目时间限制为 2000ms，时间较宽裕，所以可以根据 </p><p>​        SG 定理打表判断即可得出答案（别跟我抬杠，说什么100也能输，麻烦先了解 ICG 博弈）</p><p>​        C++代码示范如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> sg[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bytt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x / <span class="number">100000</span>)<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (x / <span class="number">10000</span>)<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (x / <span class="number">1000</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (x / <span class="number">100</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (x / <span class="number">10</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initsg</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = bytt(n);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = n;</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = (m % (base * <span class="number">10</span>)) / base;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = temp; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            m += base;</span><br><span class="line">            sg[m] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len != <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = n;</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = len; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m *= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; base; b++)</span><br><span class="line">                sg[m + b] = <span class="number">1</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(sg, <span class="number">0</span>, <span class="keyword">sizeof</span>(sg));</span><br><span class="line">    sg[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">        <span class="keyword">if</span> (!sg[i])</span><br><span class="line">            initsg(i);</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%s&quot;</span>, &amp;str, <span class="number">128</span>) != EOF) <span class="comment">//VS下使用scanf的条件日渐严格。。。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            n *= <span class="number">10</span>;</span><br><span class="line">            n += str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sg[n])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>HDOJ：1517</p><p> <strong><em>\</em>Time Limit: 5000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)**</strong><br>Problem Description</p><p>Stan and Ollie play the game of multiplication by multiplying an integer p by one of the numbers 2 to 9. Stan always starts with p = 1, does his multiplication, then Ollie multiplies the number, then Stan and so on. Before a game starts, they draw an integer 1 &lt; n &lt; 4294967295 and the winner is who first reaches p &gt;= n.</p><p>Input</p><p>Each line of input contains one integer number n.</p><p>Output</p><p>For each line of input output one line either</p><p>Stan wins.</p><p>or</p><p>Ollie wins.</p><p>assuming that both of them play perfectly.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">162</span><br><span class="line">17</span><br><span class="line">34012226</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stan wins.</span><br><span class="line">Ollie wins.</span><br><span class="line">Stan wins.</span><br></pre></td></tr></table></figure><p>Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=University+of+Waterloo+Local+Contest+2001.09.22&amp;source=1&amp;searchmode=source">University of Waterloo Local Contest 2001.09.22</a></p><p>Recommend</p><p>LL  |  We have carefully selected several similar problems for you: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1079">1079</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1536">1536</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2147">2147</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1850">1850</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1524">1524</a> </p><p>​    </p><p>​    题目分析，有一个数为1，Stan先，Ollie后，每个人依次给1乘 2-9 的数，乘完之后由下一个人继续                        乘，给定一个数n，谁乘完之后先超过当前数，则谁获胜（ICG博弈，找N，P态）</p><p>​                            分析规律，当2&lt;=n&lt;=9时，明显可见，Stan先乘，Stan必胜</p><p>​                                                当10&lt;=n&lt;=18时，不论之前Stan乘完之后的数是几，都可以超过10-18这                                                                                个范围，Ollie必胜</p><p>​                                                当19&lt;=n&lt;=162时，不论之前Ollie乘完之后得到的是几，都可以超过</p><p>​                                                                                    19-162这个范围，Stan必胜</p><p>​                                                当163&lt;=n&lt;=324时，不论之前Stan乘完之后是几，都可超过此范围</p><p>​                                                                                    Ollie必胜</p><p>​                                                162=9x9x2</p><p>​                                                324=9x9x2x2</p><p>​                                                因为两人都不想让对方先超过，所以如果目标数字不利于自己，则会尽量                                                乘小的数据，所以得出上述结论，所以可以明显看到，范围是以18为循环</p><p>​    C++示范代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n;</span><br><span class="line">    <span class="keyword">while</span> (scanf_s(<span class="string">&quot;%lf&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">18</span>)</span><br><span class="line">            n /= <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Stan wins.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Ollie wins.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      1-博弈论
    
    </summary>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/categories/WEAKLY-E/"/>
    
    
      <category term="WEAKLY E" scheme="http://yoursite.com/tags/WEAKLY-E/"/>
    
      <category term="1-博弈论" scheme="http://yoursite.com/tags/1-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>排序时间比较</title>
    <link href="http://yoursite.com/2020/08/03/%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2020/08/03/%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83/</id>
    <published>2020-08-03T03:33:05.000Z</published>
    <updated>2020-08-03T04:08:42.596Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法时间比较</p><p>​        比较 7 种排序算法排序的时间长度</p><p>​            数字范围：产生 0-32767 之间的随机数，每个算法测试 100000个随机数排列</p><p>​            测试排序算法：冒泡排序，选择排序，插入排序，希尔排序，快速排序，堆排序，合并排序</p><p>​            随机数由头文件 stdlib.h 中所带的随机数产生器产生</p><p>​            时间由头文件 time.h 中的 clock 计时</p><p>​        冒泡排序参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = len - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Bubble(a, <span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​            选择排序参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selcet</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,h;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[k])k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k != j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[k];</span><br><span class="line">            a[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Selcet(a, <span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            插入排序参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INS</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, h;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    INS(a, <span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            希尔排序参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, h;</span><br><span class="line">    <span class="keyword">int</span> r, temp;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (r = len / <span class="number">2</span>; r &gt;= <span class="number">1</span>; r /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = r; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            j = i - r;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                a[j + r] = a[j];</span><br><span class="line">                j -= r;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + r] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Shell(a, <span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            快速排序参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> ltemp = left;</span><br><span class="line">    <span class="keyword">int</span> rtemp = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> key = a[left];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++ltemp] &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ltemp == right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a[--rtemp] &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rtemp == left) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ltemp &gt;= rtemp) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = a[ltemp];</span><br><span class="line">        a[ltemp] = a[rtemp];</span><br><span class="line">        a[rtemp] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = a[left];</span><br><span class="line">    a[left] = a[rtemp];</span><br><span class="line">    a[rtemp] = temp;</span><br><span class="line">    Quick(a, left, rtemp - <span class="number">1</span>);</span><br><span class="line">    Quick(a, rtemp + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Quick(a, <span class="number">0</span>, <span class="number">99999</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            堆排序参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j + <span class="number">1</span>])j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[i];</span><br><span class="line">        a[i] = t;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[k] &lt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                t = a[k];</span><br><span class="line">                a[k] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack(a, <span class="number">99999</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            合并排序参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeOne</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, s, e;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s + len &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        e = s + <span class="number">2</span> * len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (e &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            e = n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = s;</span><br><span class="line">        i = s;</span><br><span class="line">        j = s + len;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s + len &amp;&amp; j &lt;= e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                b[k++] = a[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                b[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s + len)</span><br><span class="line">        &#123;</span><br><span class="line">            b[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= e)</span><br><span class="line">        &#123;</span><br><span class="line">            b[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        s = e + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; s &lt; n; s++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[s] = a[s];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">int</span> h, count, len, f;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;内存分配失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MergeOne(p, a, n, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            MergeOne(a, p, n, len);</span><br><span class="line">        &#125;</span><br><span class="line">        len = len * <span class="number">2</span>;</span><br><span class="line">        f = <span class="number">1</span> - f;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (h = <span class="number">0</span>; h &lt; n; h++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[h] = p[h];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Merge(a, <span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            时间结果比较：</p><p><img src="https://pic.downk.cc/item/5f277ef614195aa594cc3db8.png" alt="image-20200128162246265"></p>]]></content>
    
    <summary type="html">
    
      排序时间比较
    
    </summary>
    
    
      <category term="排序时间比较" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83/"/>
    
    
      <category term="排序时间比较" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>五大基础算法-动态规划</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-08-03T03:32:51.000Z</published>
    <updated>2020-08-03T04:08:53.148Z</updated>
    
    <content type="html"><![CDATA[<p>五大基础算法（五）：动态规划</p><p>​    dynamic Programming，一种高效的解决问题的方式</p><p>​        使用于具有重复子问题和最优子结构的问题</p><p>​            重复子问题：计算最优解时有很多相同的问题</p><p>​            最优子结构：可以把局部子问题的解结合起来得到全局最优解</p><p>​            eg1：Fibonacci sequence</p><p>​                    这是一个递归算法的典型的例子，但是：计算45位需要约 33 秒（在VS2019的环境中用C++）</p><p>​                    这个时间远超解题时要求的时间，因为有许多重复计算的地方，如图</p><p><img src="https://pic.downk.cc/item/5f27829a14195aa594cd4943.jpg" alt=""></p><p>​                参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f(x - <span class="number">1</span>) + f(x - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    z = f(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total Time :&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5f2782a714195aa594cd4cc8.png" alt=""></p><p>​            为了不进行重复计算，当第一次进行了计算之后，把他们缓存起来，再次使用时直接用</p><p>​            这便是动态规划的核心思想</p><p>​            还以上述Fibonacci为例</p><p>​                当第一次计算Fibonacci（n）时，将其缓存至 memo 中，当需要的时候，先去 memo </p><p>​                中寻找，如果找到，直接使用，没找到再计算</p><p>​            采用动态规划之后，从复杂度上来看，每次只调用 FIbonacci（n）一次，所以复杂度为：O（n）</p><p>​            在同样的环境中计算45位，用时约为：0.055秒</p><p>​                参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">45</span>;</span><br><span class="line">    memo = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(x + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        memo[i] = memo[i - <span class="number">1</span>] + memo[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; memo[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total Time :&quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5f2782b314195aa594cd511b.png" alt=""></p><p>​        eg2：0—1背包问题</p><p>​                首先，明确动态规划的两个条件：1，具有最优子结构，2，具有重复子问题</p><p>​                0—1背包与动态规划的联系为：二叉决策树</p><p>​                        问题：有一个背包，容量 M=150KG ，有 7 个物品，物品不可分割为任意大小，</p><p>​                                    要求让装入背包的物品总价最大，但不能超过背包容量</p><p>​                        物品：  A        B       C      D       E        F      G</p><p>​                        重量： 35      30      6     50      40     10    25    （KG）</p><p>​                        价值： 10      40     30    50      35     40    30    （软妹币）</p><p>​                    原题有7个物品，为方便演示说明思想，将 7 个物品暂时换为以下 4 个</p><p>​                        物品：a            b            c            d</p><p>​                        重量：3            3            2            5</p><p>​                        价值：6            7            8            9</p><p>​                        容量 M：5</p><p>​                        那么，二叉决策树为：</p><p><img src="https://pic.downk.cc/item/5f2782c014195aa594cd5418.jpg" alt=""></p><p>​                        第一个  {  }  为已经选择放入背包的物品</p><p>​                        第二个  [  ]  为还剩余没有选择的物品</p><p>​                        第三个数字 为已经选择的物品的总价</p><p>​                        第四个数字 为背包剩余重量</p><p>​                        左子树代表 1 ：即拿了第二个集合的第一个物品</p><p>​                        右子树代表 0 ：即没有拿第二个物品的第一个物品</p><p>​        用这种方式来分析 0—1背包问题，明显可以使用递归来解决</p><p>​                先用递归的方式解决：对于递归，有两个边界条件：1，第二个集合为空集合</p><p>​                                                                                                        2，第四个值为 0</p><p>​                即满足边界条件的任何一个的节点为叶节点，因为树的遍历递归最终只能达到叶节点</p><p>​        C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">&#125;Bag[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BAG</span><span class="params">(<span class="keyword">int</span> BagWeight, <span class="keyword">int</span> Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BagWeight == <span class="number">0</span> || Num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Bag[Num - <span class="number">1</span>].Weight &gt; BagWeight)<span class="keyword">return</span> BAG(BagWeight, Num - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp0, temp1;</span><br><span class="line">        temp0 = BAG(BagWeight, Num - <span class="number">1</span>);</span><br><span class="line">        temp1 = Bag[Num - <span class="number">1</span>].Value + BAG(BagWeight - Bag[Num - <span class="number">1</span>].Weight, Num - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> temp0 &gt; temp1 ? temp0 : temp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> BagWeight, Num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; BagWeight &gt;&gt; Num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Bag[i].Weight &gt;&gt; Bag[i].Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; BAG(BagWeight, Num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        动态规划解法：</p><p>​                通过二叉决策树之后，满足了两个使用动态规划的条件，</p><p>​                    1，最优子结构：每个父节点会组合子节点的解来得到 以父节点为根 的子树的最优解</p><p>​                    2，重复子问题：同一层的每个节点剩余的可选物品集合都是一样的</p><p>​                    核心：提供一个 memo ，缓存已经计算过的值</p><p>​        C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> dp[Max][Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BAG</span><span class="params">(<span class="keyword">int</span> BagWeight,<span class="keyword">int</span> Num,<span class="keyword">int</span> w[],<span class="keyword">int</span> v[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= BagWeight; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[Num][BagWeight];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w[Max];</span><br><span class="line">    <span class="keyword">int</span> v[Max];</span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    <span class="keyword">int</span> BagWeight;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Num &gt;&gt; BagWeight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; BAG(BagWeight, Num, w, v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        要点：1 为什么动态规划速度快</p><p>​                        因为不需要调用函数重复计算子问题，相比于递归，快的程度取决于重复子问题的多少</p><p>​                    2 核心</p><p>​                        核心在于设计一个 memo，保存子问题的相应答案</p><p>​                    3 设计</p><p>​                        首先判断是否满足：具有最优子结构和重复子问题，然后使用递归完成问题，</p><p>​                        然后设计 memo，修改递归程序，加入 memo，实现动态规划</p>]]></content>
    
    <summary type="html">
    
      动态规划
    
    </summary>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/categories/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/tags/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>五大基础算法-分支限界</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C/</id>
    <published>2020-08-03T03:32:42.000Z</published>
    <updated>2020-08-03T04:09:14.162Z</updated>
    
    <content type="html"><![CDATA[<p>五大基础算法（四）：分支限界</p><p>​                                在学习这个算法之前，请务必掌握回溯算法</p><p>​    分支限界即采用广度优先的策略，依次搜索所有的分支</p><p>​    限界：为了有效选择下一节点，加速搜索的进程，在每一个或节点处，计算一个函数值</p><p>​                根据计算的函数值，从当前活节点中选择最好的节点作为扩展结点，朝着最优解的分支推进</p><p>​    思想：以广度优先或最小耗费（最大效益）的优先方式求解空间树</p><p>​            （1）每一个活结点只有一次机会成为扩展结点，一旦成为扩展结点，一次性产生其所有子节点</p><p>​                    在这些子结点中，导致不可行解和非最优解的的子节点被舍弃，其余子节点加入活结点表中</p><p>​            （2）此后，从活结点中取下一节点成为当前扩展结点</p><p>​            （3）重复，直到活结点为空或求的所需解为止</p><p>​    对比分支限界与回溯</p><p><img src="https://pic.downk.cc/item/5f2781d014195aa594cd0a30.png" alt=""></p><p>​    重点：（1）设计合适的限界函数</p><p>​                            可在节点扩展时删除不必要的节点，提高效率</p><p>​                （2）组织活结点表</p><p>​                            从活结点表中选择下一扩展结点，不同的活结点有不同的搜索方式    </p><p>​                        1，队列式</p><p>​                            将活结点表组织为一个队列，按先进先出选取下一个扩展结点</p><p>​                        2，优先队列式</p><p>​                            将活结点表组成一个优先队列，并选取优先级最高的活结点成为扩展结点</p><p>​                        3，确定最优解的解向量</p><p>​                            （1）对每个扩展结点保存从根节点到该节点的路径</p><p>​                            （2）在搜索过程中构建搜索经过的树结构</p><p>​    提高搜索效率：</p><p>​                首先确定目标值的上下界，边搜索边剪枝，剪枝需要合理的判断方案，决定取舍</p><p>​                    （1）对于最大/最小值问题，如何估算上/下限</p><p>​                    （2）怎样从活结点表中选择另一个节点作为扩展结点</p><p>​                    （3）怎样展开一棵树的搜索，广度优先/宽度广度结合</p><p>​    eg1：单源最短路径</p><p>​            给定带权有向图G=（V，E），权为非负实数，给定 V 中一个顶点为原点</p><p>​            计算从原点到其他各顶点的最短路径长度（权和）</p><p><img src="https://pic.downk.cc/item/5f2781e214195aa594cd0e20.jpg" alt=""></p><p>​            分析：采用优先队列，优先级为路长</p><p>​                    （1）从 S 和空队列开始，S 扩展后，a，b，c 依次插入队列</p><p><img src="https://pic.downk.cc/item/5f2781f114195aa594cd133c.jpg" alt=""></p><p>​                    （2）从优先队列中取出最小路长的结点作为当前扩展结点，依次检查扩展结点的所有顶点</p><p>​                    （3）如果从当前扩展结点 I 到顶点 J 有边可达，且从源出发，经过 I 到 J 的路长小于当前最                            优解，则作为活结点加入优先队列，直到活结点为空</p><p><img src="https://pic.downk.cc/item/5f2781ff14195aa594cd17b8.jpg" alt=""></p><p>​    eg2：0—1背包问题</p><p>​        假设一个 0—1 背包，n=3，重量W=（16，15，15），价值为 V=（45，25，25），限重 w=30，</p><p>​        解向量为 X=（X1，X2，X3），解空间树如图示</p><p><img src="https://pic.downk.cc/item/5f27820d14195aa594cd1da0.jpg" alt=""></p><p>​        法1：采用队列式</p><p>​            用 FIFO 表示队列，初始化时，FIFO=【】，过程如下：（括号中前数字为重量，后数字为价值）</p><p>​            1，根节点 A（0，0）进队，FIFO=【A】</p><p>​            2，出队A。B（16，45），C（0，0）进队，FIFO=【B，C】</p><p>​            3，出队 B。其 D（31，70）超重，为死节点，E（16，45）进队，FIFO=【C，E】</p><p>​            4，出队 C。其 F（15，25），G（0，0）进队，FIFO=【E，F，G】</p><p>​            5，出队 E。其 J（31，70）为死节点，K（16，45），为一个可行节（1，0，0）</p><p>​            6，出队 F。其 L（30，50）为一个可行解（0，1，1），</p><p>​                M（15，25）为一个可行解（0，1，0），FIFO=【G】</p><p>​            7，出队 G。其 N（15，25）为可行解（0，0，1），O（0，0）为可行解（0，0，0）</p><p>​                FIFO=【】，结束</p><p><img src="https://pic.downk.cc/item/5f27821c14195aa594cd21e1.jpg" alt=""></p><p>​                设计限界函数：求装入背包的最大价值，用上界</p><p>​                要尽可能装入最有价值的物品，按单位重量价值递减排序</p><p>​                即：在不超重的条件下，先获取单位价值高的物品</p><p>​                对于第 I 层的某个节点 e，e.w 表示搜到 e 时已装入的重量</p><p>​                                                            e.v 表示已装入的总价值</p><p>​                                                            e.ub 为上界</p><p>​                如果余下物品只能部分装入： e.ub = e.w+(W-e.w)*V[I]/W[I]</p><p>​                如果可以全部装入：e.ub = sumV</p><p>​                解决方案：（1）先将求出上界的根节点进队</p><p>​                                    （2）在队列不为空时循环：先出队一个节点 e，检查其左子节点，并求出上界</p><p>​                                            若满足约束条件（e.w+w【e.i+1】&lt;=w），将其进队，否则左子节点死</p><p>​                                    （3）在检查右子节点并求出上界，若可行（上界&gt;已找到的可行解最大值）进队，</p><p>​                                            否则沿该点不可能找到最优解，剪枝</p><p>​                                    （4）循环至队列为空，输出最优解向量和最大总和</p><p><img src="https://pic.downk.cc/item/5f27822a14195aa594cd26f4.jpg" alt=""></p><p>​        法2：优先队列式</p><p>​            设计限界函数，优先级以限界函数为基础，用大根堆表示活结点表，取优先级为活结点所获价值</p><p><img src="https://pic.downk.cc/item/5f27823814195aa594cd2bae.jpg" alt=""></p><p>因为分支限界法最坏的情况为：遍历整个空间树，所以最长时间，空间复杂度为：O（2^N）</p>]]></content>
    
    <summary type="html">
    
      分支限界
    
    </summary>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/categories/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/tags/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="分支限界" scheme="http://yoursite.com/tags/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>五大基础算法-回溯算法</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-03T03:32:35.000Z</published>
    <updated>2020-08-03T04:09:29.463Z</updated>
    
    <content type="html"><![CDATA[<p>五大基础算法（三）：回溯算法</p><p>​    深度优先策略的典型应用，即沿着一条路向下走，如果走不通，在回退或者称为回溯到上一个</p><p>​    有分岔路的节点，选另一条路再次向下走，一直递归重复，直到遍历了全部的解。</p><p>​        例一：皇后问题</p><p>​            N皇后问题指的是：在 N*N 的棋盘中放置 N 个皇后，要使这 N 个皇后之间无法相吃</p><p>​            即：这 N 个皇后既不在一行，也不在一列，也不在一条对角线上，以下以 4 皇后举例：</p><p>​                首先给第一个皇后安排位置，可安排在（0，0）（0，1）（0，2）（0，3）：</p><p><img src="https://pic.downk.cc/item/5f2786d214195aa594ce8dde.png" style="zoom:50%;" /></p><p>​                第二个皇后只能安排到（1，2）（1，3），先安排到（1，2）：</p><p>​                                                                         <img src="https://pic.downk.cc/item/5f27807014195aa594cca510.png" style="zoom:50%;" /></p><p>​                第三个皇后无法安排：返回到安排第二个皇后时的位置，重新安排第二个皇后：</p><p>​                第二个皇后安排到（1，3）：</p><p><img src="https://pic.downk.cc/item/5f27808c14195aa594ccac20.png" style="zoom:50%;" /></p><p>​                第三个皇后只能安排在（2，1）：</p><p>​                                                                          <img src="https://pic.downk.cc/item/5f2780de14195aa594ccc531.png" style="zoom:50%;" /></p><p>​                第四个皇后无法安排则继续向上回溯，重新安排第三个皇后，第三个皇后无其他位置</p><p>​                返回重新安排第二个皇后，第二个皇后也无其他位置安排，返回第一个皇后：</p><p>​                                                                          <img src="https://pic.downk.cc/item/5f2780f414195aa594cccb74.png" style="zoom:50%;" /></p><pre><code>             则第二个皇后只能安排到（1，3）：</code></pre><p>​                                                                          <img src="https://pic.downk.cc/item/5f27810c14195aa594ccd25e.png" style="zoom:50%;" /></p><p>​                则第三个皇后只能安排到（3，0）：</p><p>​                                                                         <img src="https://pic.downk.cc/item/5f27812214195aa594ccd8b5.png" style="zoom:50%;" />              </p><p>​                则第四个皇后只能安排到（4，2）：</p><p>​                                                                         <img src="https://pic.downk.cc/item/5f27814a14195aa594cce49e.png" style="zoom:50%;" /></p><p>​                找到了一种解。</p><p>​        C++代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutPut</span><span class="params">(<span class="keyword">bool</span> Board[<span class="number">8</span>][<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++counts;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; counts &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Board[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">bool</span> Board[<span class="number">8</span>][<span class="number">8</span>], <span class="keyword">int</span> row, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt; row; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Board[i][R])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = row - <span class="number">1</span>;</span><br><span class="line">    j = R - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Board[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --i;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    i = row - <span class="number">1</span>;</span><br><span class="line">    j = R + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Board[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --i;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueenS</span><span class="params">(<span class="keyword">bool</span> Board[<span class="number">8</span>][<span class="number">8</span>],<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Board[R][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(Board, R, i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R + <span class="number">1</span> == <span class="number">8</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                OutPut(Board);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                QueenS(Board, R + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Board[R][i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> Board[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Board[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QueenS(Board, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;共有&quot;</span> &lt;&lt; counts &lt;&lt; <span class="string">&quot;种解法&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        例二：迷宫回溯找到全部路径且输出最优解</p><p>​            自定义一个任意大小的迷宫，输入起始坐标，终点坐标，迷宫中</p><p>​            0代表墙壁，1代表路径，2代表已经走过的路径</p><p>​            示例迷宫如下：</p><p>​                                  <img src="https://pic.downk.cc/item/5f27817814195aa594ccee33.png" alt=""></p><p>​            因为要找到全部路径，且有可能遇到死路，要退回重新选择，所以，栈的数据储存方式</p><p>​            很适合解决这个问题。</p><p>​            库：<assert> 可以很好的辅助构建栈的结构的相关功能函数</p><p>​                    C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maze[N][M] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Set Data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Data <span class="built_in">array</span>[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(p);</span><br><span class="line">    p-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SatckDestroy</span><span class="params">(Stack* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack* p, Data data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(p-&gt;top &lt; MaxSize);</span><br><span class="line">    p-&gt;<span class="built_in">array</span>[p-&gt;top++] = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(p-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line">    p-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Data <span class="title">StackTop</span><span class="params">(Stack* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;<span class="built_in">array</span>[p-&gt;top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackSize</span><span class="params">(Stack* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackIsEmpty</span><span class="params">(Stack* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;top &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackIsFull</span><span class="params">(Stack* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;top &gt;= MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackCopy</span><span class="params">(Stack* dest, Stack* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src-&gt;top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dest-&gt;<span class="built_in">array</span>[i] = src-&gt;<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dest-&gt;top = src-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPrint</span><span class="params">(Stack* p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;X=&quot;</span> &lt;&lt; p-&gt;<span class="built_in">array</span>[i].x &lt;&lt; <span class="string">&quot; Y=&quot;</span> &lt;&lt; p-&gt;<span class="built_in">array</span>-&gt;y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MazePrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; maze[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set Start = &#123; <span class="number">5</span>,<span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsExit</span><span class="params">(Set pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos.y == M - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsPass</span><span class="params">(Set pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maze[pos.x][pos.y] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line">Stack <span class="built_in">min</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maze</span><span class="params">(Set pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Set now = pos;</span><br><span class="line">    Set next;</span><br><span class="line">    StackPush(&amp;<span class="built_in">stack</span>, now);</span><br><span class="line">    maze[now.x][now.y] = <span class="number">2</span>;</span><br><span class="line">    MazePrint();</span><br><span class="line">    <span class="keyword">if</span> (IsExit(now))</span><br><span class="line">    &#123;</span><br><span class="line">        maze[now.x][now.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (StackIsEmpty(&amp;<span class="built_in">min</span>) || StackSize(&amp;<span class="built_in">stack</span>) &lt; StackSize(&amp;<span class="built_in">min</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            StackCopy(&amp;<span class="built_in">min</span>, &amp;<span class="built_in">stack</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功走出迷宫，走了&quot;</span> &lt;&lt; StackSize(&amp;<span class="built_in">stack</span>) &lt;&lt; <span class="string">&quot;步&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        StackPrint(&amp;<span class="built_in">stack</span>);</span><br><span class="line">        StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.x = now.x;</span><br><span class="line">    next.y = now.y<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (IsPass(next))</span><br><span class="line">    &#123;</span><br><span class="line">        MazePrint();</span><br><span class="line">        Maze(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.x = now.x - <span class="number">1</span>;</span><br><span class="line">    next.y = now.y;</span><br><span class="line">    <span class="keyword">if</span> (IsPass(next))</span><br><span class="line">    &#123;</span><br><span class="line">        MazePrint();</span><br><span class="line">        Maze(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.x = now.x;</span><br><span class="line">    next.y = now.y+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (IsPass(next))</span><br><span class="line">    &#123;</span><br><span class="line">        MazePrint();</span><br><span class="line">        Maze(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.x = now.x + <span class="number">1</span>;</span><br><span class="line">    next.y = now.y;</span><br><span class="line">    <span class="keyword">if</span> (IsPass(next))</span><br><span class="line">    &#123;</span><br><span class="line">        MazePrint();</span><br><span class="line">        Maze(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    maze[now.x][now.y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MazePrint();</span><br><span class="line">    StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    StackInit(&amp;<span class="built_in">min</span>);</span><br><span class="line">    Maze(Start);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最短路径长度为&quot;</span> &lt;&lt; StackSize(&amp;<span class="built_in">min</span>);</span><br><span class="line">    StackPrint(&amp;<span class="built_in">min</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      回溯算法
    
    </summary>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/categories/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/tags/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>五大基础算法-贪心算法</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-03T03:32:25.000Z</published>
    <updated>2020-08-03T04:09:41.537Z</updated>
    
    <content type="html"><![CDATA[<p>五大基础算法（二）：贪心算法</p><p>​    在较难取得全局的最优解时，获取各个局部的最优解，不一定能取得全局最优解</p><p>​    是否能取得全局最优解主要是对于取局部最优解时策略的选择</p><p>​    思路：取局部最优解</p><p>​        例一：0—1背包问题</p><p>​            有一个背包，其容量为 M=150KG 。现在有7个物品，物品不可分割为任意大小。</p><p>​            要求：尽可能让装入背包的物品总价值最大，但不能超过其容量。</p><p>​            物品：  A        B       C      D       E        F      G</p><p>​            重量： 35      30      6     50      40     10    25    （KG）</p><p>​            价值： 10      40     30    50      35     40    30    （软妹币）</p><p>​            价比：0.29  1.33     5      1    0.875   4     1.2    （价值/重量）</p><p>​        策略：（1）：每次挑选价值最大的物品</p><p>​                总价                物品总重量                背包剩余重量                已选物品编号</p><p>​                50                    50                                90                                    D</p><p>​                90                    60                                90                                    D F</p><p>​                130                  90                                60                                    B D F</p><p>​                165                  130                              20                                    B D E F</p><p>​                195                  136                              14                                    B C D E F</p><p>​        背包最后剩余 14KG 未装入物品，导致装入包内物品性价比下降，不是最优策略。</p><p>​                     （2）：每次挑选物品最重的</p><p>​                总价                物品总重量                背包剩余重量                已选物品编号</p><p>​                50                    50                               90                                  D</p><p>​                85                    90                               50                                  D E</p><p>​                95                    125                             25                                  A D E</p><p>​                125                  150                             0                                    A D E G</p><p>​        其价值远小于第一种策略，虽然可用重量全部用完，不是最优策略。</p><p>​                    （3）：每次选择物品价比最高的</p><p>​                总价                物品总价值                背包剩余重量                已选物品编号</p><p>​                30                    6                                144                                 C</p><p>​                70                    16                              134                                 C F</p><p>​                110                  46                              104                                 B C F</p><p>​                140                  71                              79                                   B C F G</p><p>​                190                  121                            29                                   B C D F G</p><p>​        无可拿取物品，剩余空间导致所拿物品价比下降，不是最优策略</p><p>​        如果物品可分为任意大小，则此方案为最优</p><p>​        得出：不可分割的 0—1背包问题无法由贪心策略得出全局最优解</p><p>​        例二：马踏棋盘</p><p>​            在 8*8 的国际象棋棋盘中，从任意指定位置用马出发，为其寻找一条走遍棋盘且每一个</p><p>​            格子只经过一次的路径</p><p>​            策略：如果采用深度优先即循环遍历所有可行节点，时间会过于长，效率很差，采用贪心。</p><p>​            每次走的为下一步的 下一步可走的个数少 的地方为贪心策略。</p><p>​            如果选择下一步的 下一步可走数目多的地方，容易造成自己的路径将自己围起来导致无解的情                  况发生。</p><p>​            此题用此贪心策略可大大减少所需时间，并且可以通过局部最优解达到全局最优解。</p><p>​        C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coord</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> chessboard[<span class="number">8</span>][<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">travel</span><span class="params">(Coord Start)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Coord <span class="built_in">move</span>[<span class="number">8</span>] = &#123; &#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">    Coord next[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> ways[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    Coord Now, Temp;</span><br><span class="line">    <span class="keyword">int</span> count, count1, <span class="built_in">min</span>, TempT;</span><br><span class="line">    Now = Start;</span><br><span class="line">    chessboard[Now.x][Now.y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= <span class="number">64</span>; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">8</span>; m++)</span><br><span class="line">        &#123;</span><br><span class="line">             ways[m] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Temp.x = Now.x + <span class="built_in">move</span>[j].x;</span><br><span class="line">            Temp.y = Now.y + <span class="built_in">move</span>[j].y;</span><br><span class="line">            <span class="keyword">if</span> (Temp.x &lt; <span class="number">0</span> || Temp.y &lt; <span class="number">0</span> || Temp.x&gt;<span class="number">7</span> || Temp.y&gt;<span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[Temp.x][Temp.y] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next[count1] = Temp;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = count1;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) <span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; count; m++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Temp.x = next[m].x + <span class="built_in">move</span>[j].x;</span><br><span class="line">                    Temp.y = next[m].y + <span class="built_in">move</span>[j].y;</span><br><span class="line">                    <span class="keyword">if</span> (Temp.x &lt; <span class="number">0</span> || Temp.y &lt; <span class="number">0</span> || Temp.x&gt;<span class="number">7</span> || Temp.y&gt;<span class="number">7</span>)                                  <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (chessboard[Temp.x][Temp.y] == <span class="number">0</span>)  ways[m]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TempT = ways[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; count; m++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ways[m] &lt; TempT)</span><br><span class="line">                &#123;</span><br><span class="line">                    TempT = ways[m];</span><br><span class="line">                    <span class="built_in">min</span> = m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Now = next[<span class="built_in">min</span>];</span><br><span class="line">        chessboard[Now.x][Now.y] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Coord Start;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入马的起始坐标:&quot;</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Start.x &gt;&gt; Start.y;</span><br><span class="line">    <span class="keyword">if</span> (Start.x &lt; <span class="number">1</span> || Start.y &lt; <span class="number">1</span> || Start.x&gt;<span class="number">8</span> || Start.y&gt;<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;坐标输入有误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Start.x -= <span class="number">1</span>;</span><br><span class="line">    Start.y -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (travel(Start)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;马走的顺序如下&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; chessboard[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无解&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      贪心算法
    
    </summary>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/categories/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="五大基础算法" scheme="http://yoursite.com/tags/%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
